<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Solid-State Quantum Nuclear Energy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Reveal.js Base CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reset.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css" />
    <!-- Theme -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/sky.min.css" />

    <!-- MathJax for rendering LaTeX formulas -->
    <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0&features=es7%2Ces6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>

    <style>
      .reveal h1,
      .reveal h2,
      .reveal h3 {
        color: #42a5f5;
        text-transform: none;
        margin-bottom: 20px;
      }
      .reveal h2 {
        font-size: 1.8em;
      }
      .reveal h3 {
        font-size: 1.2em;
      }
      .highlight {
        color: rgb(250, 189, 46);
        font-weight: bold;
      }
      .reveal p,
      .reveal li {
        font-size: 0.58em;
        line-height: 1.5;
        text-align: left;
        margin-bottom: 15px;
      }
      .reveal section > ul > li {
        font-size: 0.55em;
      }
      .reveal section > ul > li > ul > li {
        font-size: 0.77em;
      }
      .reveal ul {
        display: block;
        margin-left: 5%;
        margin-right: 5%;
      }
      /* Footnote layout */
      .reveal section.has-footnote {
        display: block;
      }
      .reveal .progress {
        height: 10px;
      }
      .reveal .progress span {
        height: 100%;
      }
      .reveal .slide-number {
        font-size: 0.8em;
        padding: 6px 10px;
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        border-radius: 6px;
        right: 4em;
        bottom: 16px;
        transition: opacity 200ms ease;
      }
      /* Hide the slide counter on chapter covers + the very first slide (JS toggles this class). */
      .reveal.slide-number-hidden .slide-number {
        opacity: 0;
        pointer-events: none;
      }
      /* Footnote styling */
      .footnote {
        position: relative;
        font-size: 0.4em !important;
        color: #aaa !important;
        text-align: left !important;
        border-top: 1px solid #555;
        padding-top: 6px;
        width: 90%;
        margin: 0 auto;
        line-height: 1.2 !important;
      }
      /* Center text helper */
      .center-text {
        text-align: center !important;
      }
      /* Chapter break slides */
      .reveal section.chapter {
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      .reveal section.chapter h2 {
        color: #fff;
        font-size: 2.2em;
        margin-bottom: 0.2em;
      }
      .reveal section.chapter p {
        color: rgba(255, 255, 255, 0.85) !important;
        text-align: center !important;
        font-size: 0.9em !important;
        margin: 0.2em 0 0 !important;
      }
      /* Undim all fragments on demand */
      .reveal.fragments-off .fragment,
      .reveal.fragments-off .fragment.visible,
      .reveal section.undim .fragment.visible {
        opacity: 1 !important;
      }
      /* Shortcut legend */
      .reveal .shortcut-legend {
        position: absolute;
        right: var(--legend-right, 6em);
        bottom: var(--legend-bottom, 16px);
        z-index: 30;
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 0.3em;
        pointer-events: auto;
      }
      .reveal .shortcut-legend.is-hidden {
        display: none;
      }
      .reveal .shortcut-legend.is-hidden-by-user {
        display: none;
      }
      .reveal .shortcut-item {
        position: relative;
        display: inline-flex;
        flex-direction: row;
        align-items: center;
        gap: 4px;
        padding: 2px 5px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.16);
        color: rgba(255, 255, 255, 0.6);
        transition:
          color 160ms ease,
          background 160ms ease,
          border-color 160ms ease;
        user-select: none;
      }
      .reveal .shortcut-item.is-on {
        color: #fff;
        background: rgba(0, 0, 0, 0.35);
      }
      .reveal .shortcut-item.is-on .shortcut-key {
        background: rgba(0, 0, 0, 0.35);
      }
      .reveal .shortcut-item.is-hidden {
        display: none;
      }
      .reveal .shortcut-key {
        display: inline-block;
        min-width: 0.9em;
        text-align: center;
        padding: 1px 4px;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.3);
        font-weight: 600;
        letter-spacing: 0.02em;
      }
      .reveal .shortcut-item::after {
        content: attr(data-tooltip);
        position: absolute;
        right: 0;
        bottom: calc(100% + 6px);
        padding: 6px 8px;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        font-size: 0.95em;
        white-space: nowrap;
        opacity: 0;
        transform: translateY(4px);
        transition:
          opacity 160ms ease,
          transform 160ms ease;
        pointer-events: none;
      }
      .reveal .shortcut-item:hover::after {
        opacity: 1;
        transform: translateY(0);
      }
      @property --vortex-spin {
        syntax: '<angle>';
        inherits: true;
        initial-value: 0deg;
      }
      @property --wobble-blur {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-x {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-y {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-x-fast {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-y-fast {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-x-slow {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-y-slow {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-blur-fast {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-blur-slow {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-contrast {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-contrast-fast {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-contrast-slow {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-strength {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-fast-mix {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-slow-mix {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --shimmer-phase {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      .reveal {
        --shimmer-strength: 0;
        --speckle-strength: 0;
        --wobble-amount: 0px;
        --wobble-jitter: 0px;
        --wobble-contrast-amount: 0;
        --wobble-strength: 0;
        --precession-amount: 0deg;
        --wobble-fast-duration: 0.1s;
        --wobble-slow-duration: 0.6s;
        --wobble-echo-duration: 1s;
        --precession-duration: 5.2s;
        --shimmer-duration: 1.9s;
        --speckle-duration: 6.2s;
      }
      .reveal.effect-shimmer {
        --shimmer-strength: 0.85;
      }
      .reveal.effect-speckle {
        --speckle-strength: 0.45;
      }
      .reveal.effect-wobble {
        --wobble-amount: 2.1px;
        --wobble-jitter: 1.32px;
        --wobble-contrast-amount: 0.31;
        --wobble-strength: 1;
        --wobble-fast-duration: 0.1s;
        --wobble-slow-duration: 0.6s;
        --wobble-echo-duration: 1s;
      }
      .reveal.effect-precession {
        /* Rock amplitude (30% less than 72deg). */
        --precession-amount: 4.2deg;
        /* Rock speed: 0.2s period. */
        --precession-duration: 0.06s;
      }
      /* Effect 4 visibility: use a stronger blend mode without changing vortex color/alpha knobs. */
      .reveal.effect-precession .quantum-ripple {
        mix-blend-mode: overlay;
      }
      /* The class that triggers the Vector Potential distortion */
      .coherent-lattice-active {
        /* Apply the invisible SVG math to the whole slide */
        filter: url(#vector-potential);
        -webkit-filter: url(#vector-potential);

        /* Optional: slightly scale up to prevent edges from pulling inward during distortion */
        transform: scale(1.02);
      }
      .reveal .slide-background.present,
      .reveal .slide-background.present .slide-background-content {
        overflow: hidden;
      }
      .reveal .slide-background.present .slide-background-content {
        position: relative;
      }
      /* Container that holds the ripples behind the text but above the background */
      .quantum-ripple-container {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        z-index: 2; /* Ensure ripples render above slide backgrounds */
        pointer-events: none; /* Prevents it from interfering with clicks/swipes */
      }

      /* The Ripple Element */
      .quantum-ripple {
        position: absolute;
        border-radius: 50%;
        /* Vortex-like swirl that picks up background hues via blend mode */
        background:
          radial-gradient(
            circle at 50% 50%,
            rgba(0, 0, 0, var(--vortex-core, 0.38)) 0%,
            rgba(0, 0, 0, var(--vortex-inner, 0.2)) 28%,
            rgba(255, 255, 255, var(--vortex-highlight, 0.08)) 55%,
            rgba(255, 255, 255, 0) 75%
          ),
          conic-gradient(
            from var(--vortex-spin, 0deg),
            rgba(255, 255, 255, var(--vortex-highlight-strong, 0.34)),
            rgba(255, 255, 255, 0) 30%,
            rgba(0, 0, 0, var(--vortex-shadow, 0.26)) 54%,
            rgba(255, 255, 255, var(--vortex-highlight, 0.3)) 78%,
            rgba(255, 255, 255, var(--vortex-highlight-strong, 0.34))
          );
        background-blend-mode: multiply;
        mix-blend-mode: soft-light;
        box-shadow:
          inset 0 0 18px rgba(0, 0, 0, 0.28),
          0 0 14px rgba(255, 255, 255, 0.08);
        filter: blur(calc(var(--vortex-blur, 1.3px) + var(--wobble-blur-fast, 0px) + var(--wobble-blur-slow, 0px)))
          saturate(1.25)
          contrast(calc(var(--vortex-contrast, 1.12) + var(--wobble-contrast-fast, 0) + var(--wobble-contrast-slow, 0)))
          brightness(calc(1 + ((var(--wobble-contrast-fast, 0) + var(--wobble-contrast-slow, 0)) * 0.6)));
        -webkit-mask: radial-gradient(
          circle,
          rgba(0, 0, 0, 0) 28%,
          rgba(0, 0, 0, 0.12) 36%,
          rgba(0, 0, 0, 0.82) 50%,
          rgba(0, 0, 0, 0.6) 70%,
          rgba(0, 0, 0, 0) 84%
        );
        mask: radial-gradient(
          circle,
          rgba(0, 0, 0, 0) 28%,
          rgba(0, 0, 0, 0.12) 36%,
          rgba(0, 0, 0, 0.82) 50%,
          rgba(0, 0, 0, 0.6) 70%,
          rgba(0, 0, 0, 0) 84%
        );
        transform: translate(-50%, -50%) scale(0) rotate(0deg);
        opacity: 0;
        /* Slower, smoother expansion */
        animation:
          expandRipple var(--expand-duration, 8s) cubic-bezier(0.2, 0.6, 0.2, 1) forwards,
          rippleWobbleFast var(--wobble-fast-duration, 0.1s) ease-in-out infinite,
          rippleWobbleSlow var(--wobble-slow-duration, 0.6s) ease-in-out infinite,
          rippleWobbleEcho var(--wobble-echo-duration, 1s) ease-out infinite,
          ripplePrecession var(--precession-duration, 5.2s) ease-in-out infinite;
      }
      .quantum-ripple::before,
      .quantum-ripple::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 50%;
        pointer-events: none;
      }
      .quantum-ripple::before {
        background: inherit;
        mix-blend-mode: screen;
        filter: blur(0.8px);
        opacity: calc(var(--shimmer-strength, 0) * var(--shimmer-phase, 0));
        animation: rippleShimmer var(--shimmer-duration, 1.9s) ease-in-out infinite;
      }
      .quantum-ripple::after {
        background-image: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.85) 0px,
          rgba(255, 255, 255, 0.85) 1px,
          rgba(255, 255, 255, 0) 2.2px
        );
        background-size: 7px 7px;
        mix-blend-mode: screen;
        opacity: var(--speckle-strength, 0);
        filter: blur(0.6px);
        animation: speckleDrift var(--speckle-duration, 6.2s) linear infinite;
      }

      @keyframes expandRipple {
        0% {
          transform: translate(
              calc(-50% + var(--wobble-x-fast, 0px) + var(--wobble-x-slow, 0px)),
              calc(-50% + var(--wobble-y-fast, 0px) + var(--wobble-y-slow, 0px))
            )
            scale(0) rotate(0deg);
          opacity: var(--vortex-opacity-start, 0);
        }
        12% {
          /* Swirl speed: reduce rotation to slow the vortex spin */
          transform: translate(
              calc(-50% + var(--wobble-x-fast, 0px) + var(--wobble-x-slow, 0px)),
              calc(-50% + var(--wobble-y-fast, 0px) + var(--wobble-y-slow, 0px))
            )
            scale(0.45) rotate(96deg);
          opacity: var(--vortex-opacity-mid, 0.55);
        }
        100% {
          /* Swirl speed: total rotation amount (20% slower than before) */
          transform: translate(
              calc(-50% + var(--wobble-x-fast, 0px) + var(--wobble-x-slow, 0px)),
              calc(-50% + var(--wobble-y-fast, 0px) + var(--wobble-y-slow, 0px))
            )
            scale(3.2) rotate(370deg);
          opacity: var(--vortex-opacity-end, 0);
        }
      }
      @keyframes rippleShimmer {
        0%,
        100% {
          --shimmer-phase: 0.2;
        }
        50% {
          --shimmer-phase: 1;
        }
      }
      @keyframes speckleDrift {
        0% {
          transform: translate(0, 0) scale(1);
        }
        50% {
          transform: translate(-6%, 4%) scale(1.02);
        }
        100% {
          transform: translate(4%, -5%) scale(1);
        }
      }
      @keyframes rippleWobbleFast {
        0%,
        100% {
          --wobble-blur-fast: calc(
            var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.5
          );
          --wobble-contrast-fast: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * 0.5
          );
          --wobble-x-fast: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.7
          );
          --wobble-y-fast: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * 0.5
          );
        }
        50% {
          --wobble-blur-fast: calc(var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0));
          --wobble-contrast-fast: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.4
          );
          --wobble-x-fast: calc(var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0));
          --wobble-y-fast: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.8
          );
        }
      }
      @keyframes rippleWobbleSlow {
        0%,
        100% {
          --wobble-blur-slow: calc(
            var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.25
          );
          --wobble-contrast-slow: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.3
          );
          --wobble-x-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.45
          );
          --wobble-y-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.4
          );
        }
        50% {
          --wobble-blur-slow: calc(
            var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.6
          );
          --wobble-contrast-slow: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.2
          );
          --wobble-x-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.6
          );
          --wobble-y-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.5
          );
        }
      }
      @keyframes rippleWobbleEcho {
        0% {
          --wobble-fast-mix: 0;
          --wobble-slow-mix: 0;
        }
        6% {
          /* Sharp attack: fast strobe dominates immediately */
          --wobble-fast-mix: 1;
          --wobble-slow-mix: 0;
        }
        30% {
          /* Begin easing into the slower wobble */
          --wobble-fast-mix: 0.75;
          --wobble-slow-mix: 0.25;
        }
        60% {
          /* Sustained phase: slower wobble becomes the lead */
          --wobble-fast-mix: 0.35;
          --wobble-slow-mix: 0.6;
        }
        100% {
          /* Echo tail: mostly slow wobble, faint fast residue */
          --wobble-fast-mix: 0.15;
          --wobble-slow-mix: 0.8;
        }
      }
      @keyframes ripplePrecession {
        0%,
        100% {
          /* Effect 4: precession uses `rotate` (individual transform) so it composes with `transform`
             from `expandRipple` (no need to animate custom properties for visibility). */
          rotate: calc(var(--precession-amount, 0deg) * -1);
        }
        50% {
          rotate: var(--precession-amount, 0deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- SLIDE: Title -->
        <section>
          <h2>
            Solid-State <br />
            Quantum Nuclear Energy
          </h2>
          <h3>
            Bridging <em>Coherent QED</em> & <br />
            Direct Energy Extraction
          </h3>
          <div class="coherent-lattice-target">
            <p class="center-text" style="margin-top: 50px; font-size: 0.9em">
              <span>\( \mathbf{4E} \xrightarrow{\text{goes}} {}^4He \)</span>
            </p>
          </div>
        </section>

        <!-- CHAPTER: Motivation -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2>Motivation</h2>
          <p>Energy is breaking the build</p>
        </section>

        <!-- SLIDE: The Energy Problem -->
        <section>
          <h2>The Energy Stack is Broken</h2>
          <p>Humanity currently relies on outdated "APIs" to extract energy from nature:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Chemical (Fossil Fuels):</strong> Easy to access, but low energy density and highly polluting
              (carbon exhaust).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Nuclear Fission:</strong> High density, but leaves behind highly toxic state (radioactive waste)
              and risks catastrophic system crashes (meltdowns).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Hot Nuclear Fusion:</strong> The dream (Tokamaks/Stellarators). We try to hold a
              100-million-degree plasma star inside a magnetic bottle. It is a brute-force hardware solution that is
              notoriously unstable.
            </li>
          </ul>
          <p class="fragment fade-in-then-semi-out">
            <strong>The Question:</strong> Is there a more elegant, software-like approach to unlocking nuclear energy
            at <strong>room temperature</strong>?
          </p>
        </section>

        <!-- CHAPTER: whatis -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <code class="center-text">$ echo $TOPIC | xargs whatis</code>
        </section>

        <!-- SLIDE: Primer 1 - Solid-State vs Hot Fusion -->
        <section>
          <h2>The "Hardware" of Fusion</h2>
          <p>Redefining what a nuclear reactor looks like:</p>

          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Hot Fusion (The Vacuum Tube):</strong> We usually think of nuclear fusion as a 100-million-degree
              plasma trapped in giant magnetic bottles (Tokamaks). It is <strong>massive</strong>, <strong>hot</strong>,
              and highly <strong>unstable</strong>.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>Solid-State Physics:</strong> Just as computing moved from hot,
              <strong>fragile vacuum tubes</strong> to quiet, <strong>stable silicon microchips</strong>, physics is
              exploring the same transition for nuclear energy.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Metal Lattice:</strong> Instead of empty space and magnets, "<strong>Solid-State</strong>"
              means the reaction happens inside the rigid, geometric <strong>crystal structure</strong> (a lattice) of a
              metal, like Titanium.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Premise:</strong> We are looking at how a stable, room-temperature metal environment might be
              the key to <strong>confining</strong> and <strong>manipulating</strong> atoms without brute force.
            </li>
          </ul>
        </section>

        <!-- SLIDE: Primer 2 - Coherence and QED -->
        <section>
          <h2>
            The "Software" of the<br />
            Quantum Realm
          </h2>
          <p>To make solid-state fusion work, we rely on advanced quantum mechanics.</p>

          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Quantum Electrodynamics (QED):</strong> This is the fundamental
              <strong>physics framework</strong> describing how <strong>light</strong> (photons) and
              <strong>matter</strong> (electrons) <strong>interact</strong>. It is essentially the "source code" of
              electromagnetism.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>Execution Model:</strong> Normally, atoms in a metal <strong>vibrate randomly</strong> and
              <strong>independently</strong> (heat/chaos). They are <strong>asynchronous</strong> and disconnected.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>Quantum Coherence:</strong> Under highly specific conditions, millions of atoms in a lattice can
              <strong>synchronize</strong> their state, vibrating together in perfect <strong>phase</strong> like a
              laser.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Macroscopic State:</strong> When a lattice becomes "<strong><em>coherent</em></strong
              >", it stops acting as billions of individual atoms and begins acting as a single,
              <strong>unified quantum system</strong>.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Potential:</strong> This unified state may offer a mechanism to bypass extreme heat and deadly
              radiation, safely <strong>managing nuclear reactions</strong>.
            </li>
          </ul>
        </section>

        <!-- CHAPTER: Evidence -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Evidence</h2>
          <p class="center-text">A room-temperature nuclear anomaly</p>
        </section>

        <!-- SLIDE: The Inciting Incident -->
        <section class="has-footnote">
          <h2>The Titanium Hydride Anomaly</h2>
          <h3>(Experiment Result)</h3>
          <p>
            Since 2017, physicists <strong>L. Gamberale</strong> and <strong>G. Modanese</strong>
            have investigated anomalies in transition metals.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Setup:</strong> They take standard Titanium Hydride powders
              <span>\( (TiH_2) \)</span>—basically titanium metal heavily loaded with standard hydrogen gas.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Trigger:</strong> They subject it to simple thermal cycles (heating up and cooling down).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Observation:</strong> The system produces <strong>Deuterium (D)</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Why is this groundbreaking? It suggests the lattice is not a passive container, but an
              <strong>active</strong> participant that <strong>orchestrates</strong> atomic bonding.
            </li>
          </ul>
          <p class="footnote">
            L. Gamberale, G. Modanese, "An Experimental Study on Deuterium Production from Titanium Hydride Powders
            Subjected to Thermal Cycles" (2024-11)
          </p>
        </section>

        <!-- SLIDE: The Physics Sanity Check -->
        <section>
          <h2>Why This <span class="highlight">MUST</span> Be Nuclear</h2>
          <p>
            Mainstream skeptics often dismiss these anomalies as "chemical errors." Here is why that is physically
            impossible:
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Energy Scale:</strong> Chemistry rearranges outer electrons (releasing a few
              <span>\( eV \)</span>). Creating Deuterium releases <span>\( \sim 1.44 \text{ MeV} \)</span>—a million
              times more energy.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Hardware Limitation / Missing Ingredient:</strong> Standard Hydrogen has 1 Proton. Deuterium
              has 1 Proton + <strong>1 Neutron</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Unbreakable Rule:</strong> Chemical reactions (Electromagnetic Force) only move electrons.
              They cannot touch the nucleus.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Altering Quarks:</strong> To get Deuterium from Hydrogen, a proton must physically be converted
              into a neutron. This strictly requires the <strong>Weak Nuclear Force</strong> to flip quarks. Chemistry
              is fundamentally incapable of this.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Conclusion:</strong> A nuclear event is definitively happening in a <strong>low-energy</strong>,
              solid-state environment. (aka. <em>Cold Fusion</em>, <em>LENR</em>)
            </li>
          </ul>
        </section>

        <!-- SLIDE: The "Missing Death" Mystery -->
        <section>
          <h2>
            The Mystery:<br />
            Where is the Radiation?
          </h2>
          <p>If a nuclear reaction is happening on a laboratory bench, why aren't the researchers dead?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              In standard vacuum physics, generating Deuterium and fusing it produces high-energy
              <strong>gamma rays</strong> and <strong>rogue neutrons</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              A rogue neutron is like a memory leak in a computer system—it penetrates surrounding materials, corrupting
              their atomic structure and making them highly radioactive.
            </li>
            <li class="fragment fade-in-then-semi-out">
              However, in these specific Titanium experiments, Geiger counters detect
              <strong>zero deadly radiation</strong>.
            </li>
          </ul>
          <p class="fragment fade-in-then-semi-out">
            How does the system successfully process a <strong>nuclear transaction</strong> without emitting<br />
            <strong>toxic matter</strong> "data corruption"?
          </p>
        </section>

        <!-- CHAPTER: Mechanism -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Mechanism</h2>
          <p class="center-text">Nuclear, but (maybe) radiation-free</p>
        </section>

        <!-- SLIDE: Step 1: The PEP Reaction -->
        <section>
          <h2>Step 1: The Neutrino Exhaust Pipe</h2>
          <p>
            To create Deuterium without radiation, the system utilizes a rare three-body interaction known as the
            <strong>PEP Reaction</strong>:
          </p>
          <p class="center-text highlight fragment fade-in"><span>\( p + e^- + p \rightarrow D + \nu_e \)</span></p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Catalyst:</strong> The dense electron cloud of the titanium lattice perfectly screens
              (reduces) the <strong>Coulomb barrier</strong> (the natural repulsion between protons).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Momentum Conservation:</strong> The reaction generates <span>\( 1.44 \text{ MeV} \)</span>.
              Because the output is a heavy Deuteron (<span>\( D \)</span>) and a nearly massless electron neutrino
              (<span>\( \nu_e \)</span>), physics dictates the lightest particle takes the energy.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Result:</strong> The <strong>neutrino</strong> carries away ~99.9% of the energy at near
              light-speed. Because neutrinos barely interact with normal matter, the energy
              <strong>safely</strong> exits the Earth entirely.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Core Engine -->
        <section class="has-footnote">
          <h2>Step 2: The 24 MeV Problem</h2>
          <h3>(Theory)</h3>
          <p>Creating Deuterium is safe, but as it accumulates, the <strong>Deuterons fuse</strong> together:</p>
          <p class="center-text highlight fragment fade-in">
            <span>\( D + D \rightarrow {}^4He + 24 \text{ MeV} \)</span>
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              In standard physics, this specific fusion emits a lethal <strong>24 MeV gamma ray</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              To explain the lack of gamma rays, Modanese relies on the legacy of<br />
              <strong>Giuliano Preparata</strong> and the theory of
              <strong>Coherent Quantum Electrodynamics (QED)</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Concept:</strong> Atoms in a tight crystalline lattice do not act as independent agents. They
              exchange photons so rapidly they enter a "<em>superradiant</em>" <strong>synchronized</strong> state.
            </li>
          </ul>
          <p class="footnote">G. Modanese, "Coherent Plasma in a Lattice" (2022-05)</p>
        </section>

        <!-- SLIDE: Unpacking Superradiance !!TODO-->
        <section>
          <h2>
            Superradiance:<br />
            The actual "magic" engine
          </h2>
          <p>To understand how a metal lattice survives a nuclear blast, we must define this synchronized state.</p>
          <ul>
            <li>
              <strong>Asynchronous Reality:</strong> Normally, atoms absorb and emit energy independently and randomly.
              Think of a standard lightbulb, or millions of independent, asynchronous threads executing code on a
              server. The energy output scales linearly (<span>\( N \)</span>).
            </li>
            <li>
              <strong>The Dicke Effect (Superradiance):</strong> In 1954, physicist Robert Dicke proved that if atoms
              are packed tightly enough (like inside a dense Titanium crystal), they couple to the exact same
              electromagnetic field.
            </li>
            <li>
              <strong>Synchronous Execution:</strong> When this happens, the atoms merge their quantum states. Instead
              of millions of independent threads, they lock into a single, perfectly synchronized execution loop.
            </li>
            <li>
              <strong>The Scaling Factor:</strong> They stop acting as billions of individual atoms and act as one giant
              "macro-atom." Their ability to emit or absorb energy suddenly scales exponentially (<span>\( N^2 \)</span
              >).
            </li>
            <li>
              <strong>The Result:</strong> This massive collective synchronization is what gives the lattice the
              capacity to instantly swallow a 24 MeV energy spike.
            </li>
          </ul>
          <p class="footnote">R. H. Dicke, "Coherence in Spontaneous Radiation Processes" (1954)</p>
        </section>

        <!-- SLIDE: Unpacking Superradiance -->
        <section>
          <h2>
            Superradiance:<br />
            The actual "magic" engine
          </h2>
          <ul>
            <li>
              <strong>Asynchronous Reality:</strong> Normally, atoms act like independent, isolated threads. Their
              energy capacity scales linearly (<span>\( N \)</span>).
            </li>
            <li>
              <strong>The Synchronization:</strong> In a dense, structured lattice, atoms can couple to the exact same
              electromagnetic field, locking into perfect phase.
            </li>
            <li>
              <strong>The "Macro-Atom":</strong> They stop behaving as billions of individual particles and merge into a
              single, unified quantum execution loop.
            </li>
            <li>
              <strong>Exponential Scaling:</strong> Because they are perfectly synchronized, their capacity to absorb
              and emit energy suddenly scales exponentially (<span>\( N^2 \)</span>).
            </li>
            <li>
              <strong>The Payoff:</strong> This massive parallel synchronization is the only mechanism that allows a
              physical crystal to instantly swallow a 24 MeV nuclear spike without vaporizing.
            </li>
          </ul>
          <p class="footnote">R. H. Dicke, "Coherence in Spontaneous Radiation Processes" (1954)</p>
        </section>

        <!-- CHAPTER: Potentials -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Potentials</h2>
          <p class="center-text">
            Why <span>\( \mathbf{A} \)</span> can matter even when <span>\( \mathbf{E}, \mathbf{B} = 0 \)</span>
          </p>
        </section>

        <!-- NEW SLIDE 8: Explaining Maxwell (Frontend vs Backend) -->
        <section>
          <h2>
            Electromagnetism:<br />
            Frontend vs. Backend
          </h2>
          <p>Let's review Maxwell’s equations of electromagnetism:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The "Frontend" Observable API:</strong> The Electric Field (<span>\( \mathbf{E} \)</span>) and
              Magnetic Field (<span>\( \mathbf{B} \)</span>). These are the physical forces we measure. They push
              electrons around. Standard antennas, radios, and gamma rays are just oscillating
              <span>\( \mathbf{E} \)</span> and <span>\( \mathbf{B} \)</span> fields.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The "Backend" Underlying State:</strong> To calculate <span>\( \mathbf{E} \)</span> and
              <span>\( \mathbf{B} \)</span>, physicists use two deeper mathematical constructs:
              <ul>
                <li>
                  The <strong>Scalar Potential (<span>\( \phi \)</span>)</strong>: Think of this like electric pressure
                  or voltage—a single number at a specific point in space.
                </li>
                <li>
                  The <strong>Vector Potential (<span>\( \mathbf{A} \)</span>)</strong>: A directional flow field.
                  <!-- prettier-ignore -->
                  Mathematically, the magnetic field is just a derivative of this underlying state
                  (<span>\( \mathbf{B} = \nabla \times \mathbf{A} \)</span>).
                </li>
              </ul>
            </li>
            <li class="fragment fade-in-then-semi-out">
              In 19th-century classical physics, <span>\( \mathbf{A} \)</span> and <span>\( \phi \)</span> were
              considered mere <br />
              "helper variables"—useful for math, but lacking physical reality.
            </li>
          </ul>
        </section>

        <!-- NEW SLIDE 9: The Quantum Reality (Aharonov-Bohm) -->
        <section>
          <h2>
            The Quantum Reality:<br />
            The Source Code
          </h2>
          <p>
            In 1959, the <strong>Aharonov-Bohm effect</strong> showed that <span>\( \mathbf{A} \)</span> and
            <span>\( \phi \)</span> are the <em>true</em> fundamental reality.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Experiment:</strong> Physicists created a region of space where both
              <span>\( \mathbf{E} = 0 \)</span> and <span>\( \mathbf{B} = 0 \)</span>, but the underlying Vector
              Potential (<span>\( \mathbf{A} \)</span>) was <strong>non-zero</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Result:</strong> Electrons passing through this "empty" space
              <strong>physically reacted</strong>. Their <strong>quantum phase</strong> (their wave state)
              <strong>shifted</strong>, despite feeling zero physical force.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Analogy:</strong> <span>\( \mathbf{E} \)</span> and <span>\( \mathbf{B} \)</span> are just the
              UI rendered on the screen. <span>\( \mathbf{A} \)</span> and <span>\( \phi \)</span> are the backend
              database. You can alter the database and change the system state even if the UI shows absolutely
              <strong>nothing</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Why this matters:</strong> To suppress a 24 MeV <strong>gamma ray</strong>, the lattice must
              manipulate the backend database (<span>\( \mathbf{A} \)</span>) directly, <strong>bypassing</strong> the
              generation of the deadly <span>\( \mathbf{E} \)</span> and <span>\( \mathbf{B} \)</span> "UI" entirely.
            </li>
          </ul>
          <p class="footnote">
            Y. Aharonov, D. Bohm, "Significance of Electromagnetic Potentials in the Quantum Theory" (1959)
          </p>
        </section>

        <!-- SLIDE: The Global State Manager !!TODO-->
        <section>
          <h2>
            The Vector Potential (<span>\( \mathbf{A} \)</span>)<br />
            as a Quantum Buffer
          </h2>
          <h3>(Or Battery)</h3>
          <p>
            The <em>superradiant</em> state generates a macroscopic electromagnetic <strong>standing wave</strong> in
            the <strong>Vector Potential (<span>\( \mathbf{A} \)</span>)</strong>.
          </p>
          <!-- "How does that superradiant 'macro-atom' actually store the energy? It writes it directly to the backend database:
          the <strong>Vector Potential (<span>\( \mathbf{A} \)</span>)</strong>." -->
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Think of the Vector Potential as a Global State Manager for the crystal.
            </li>
            <li class="fragment fade-in-then-semi-out">
              When <span>\( D + D \)</span> fuses, the 24 MeV of energy is <strong>not</strong> localized to a single
              atom.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Instead, the energy is instantly uploaded into the macroscopic
              <strong>Vector Potential standing wave</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Because the energy is <strong>absorbed</strong> by the collective field, the violent gamma-ray photon is
              never allowed to compile. The lattice acts as an electromagnetic shock absorber.
            </li>
          </ul>
        </section>

        <!-- SLIDE: Scalar Fields & Safety -->
        <section class="has-footnote">
          <h2>
            Why Doesn't the Energy<br />
            Destroy the Lattice?
          </h2>
          <p>If the lattice absorbs 24 MeV, why doesn't it just instantly vaporize?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Standard electromagnetic waves (like radio or light) are "transverse" and cause rapid
              <strong>dissipation</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Modanese proves mathematically that transient nuclear currents inside a coherent lattice generate
              <strong>Scalar (or Longitudinal) Electromagnetic Fields</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Scalar fields have a unique property: they <em>cannot</em> radiate away into free space. There is
              <strong>no dissipation</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              The energy is <strong>safely trapped</strong>, "sloshing" back and forth inside the medium without
              destroying the physical structure.
            </li>
          </ul>
          <p class="footnote">
            G. Modanese, "Aharonov-Bohm electrodynamics in material media: a scalar e.m. field cannot cause dissipation
            in a medium" (2023-02)
          </p>
        </section>

        <!-- SLIDE: Harmonic Qubits -->
        <section class="has-footnote">
          <h2>
            Translating Quantum Slosh<br />
            into Safe Heat
          </h2>
          <p>How does the system finally bleed off this trapped energy?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              The authors model the atoms of the lattice as <strong>Harmonic Qubits</strong> connected by long-range
              photon coupling.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This allows for a process called "<em>superradiant</em> decay."
            </li>
            <li class="fragment fade-in-then-semi-out">
              Instead of <strong>1 atom</strong> vibrating with <strong>24,000,000 eV</strong> of energy (which means it
              explodes), the standing wave forces <strong>1,000,000,000 atoms</strong> to vibrate
              <strong>simultaneously</strong> (coherence) with <strong>0.024 eV</strong> of energy.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Result:</strong> The <strong>massive nuclear payload</strong> is safely dispersed as
              macroscopic <em>acoustic</em> vibrations (Phonons). We experience this simply as pure, continuous
              <strong>Heat</strong>.
            </li>
          </ul>
          <p class="footnote">
            L. Gamberale, G. Modanese, "Excited states of coherent harmonic qubits with long-range photon coupling and
            dissipation" (2025-02)
          </p>
        </section>

        <!-- SLIDE: The Failsafe -->
        <section>
          <h2>The Ultimate Built-In Thermostat</h2>
          <p>Why <strong>can't</strong> this system cause a <strong>nuclear meltdown</strong> like Chernobyl?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              The entire reaction is entirely dependent on the <strong>phase coherence</strong> of the lattice.
            </li>
            <li class="fragment fade-in-then-semi-out">
              If the reaction produces heat too quickly, the titanium lattice physically expands.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This expansion <strong>breaks</strong> the precise geometry required for the standing wave. The
              <strong>Coherent Plasma collapses</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Without the Vector Potential (<span>\( \mathbf{A} \)</span>), the
              <strong>Coulomb barrier</strong> instantly <strong>returns</strong>, and the nuclear fusion
              <strong>halts</strong>. It is a physically <strong>un-hackable, self-regulating</strong> system.
            </li>
          </ul>
        </section>

        <!-- CHAPTER: Engineering -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Engineering</h2>
          <p class="center-text">Turning buffered energy into usable electricity</p>
        </section>

        <!-- SLIDE: The Engineering Bottleneck -->
        <section>
          <h2>
            The Next Problem: <br />
            Heat is Inefficient
          </h2>
          <p>
            If Modanese and Gamberale are right, we have a perfect solid-state heat generator. But heat is a terrible
            "API" for modern technology.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              To turn heat into electricity, we still rely on 19th-century technology:<br />
              <strong>boiling water</strong> to create steam to physically spin a massive magnetic turbine.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This is bottlenecked by the <strong>Carnot Limit</strong> (thermodynamic inefficiency). <br />
              We <strong>lose over 60%</strong> of the energy just in the conversion process.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Ultimate Engineering Goal:</strong> Can we extract the energy
              <em>while it is still trapped in the Vector Potential (<span>\( \mathbf{A} \)</span>)</em>, completely
              bypassing the generation of heat?
            </li>
          </ul>
        </section>

        <!-- SLIDE: Enter Hal Puthoff -->
        <section class="has-footnote">
          <h2>The Missing Circuit: Hal Puthoff</h2>
          <h3>(Patent)</h3>
          <p>
            To extract energy from the Vector Potential (<span>\( \mathbf{A} \)</span>), we must look to another <br />
            pioneer of advanced physics: <strong>Dr. Harold E. Puthoff</strong>.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Standard antennas (like Wi-Fi) only interact with oscillating Electric (<span>\( \mathbf{E} \)</span>) and
              Magnetic (<span>\( \mathbf{B} \)</span>) fields.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Puthoff designed and patented specialized <strong>quantum circuits</strong> designed specifically to
              <em>transmit</em> and <em>receive</em> signals (wireless) using <strong>only</strong> the <br />
              <strong>Vector Potential (<span>\( \mathbf{A} \)</span>)</strong>
              and <strong>Scalar Potential (<span>\( \phi \)</span>)</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This is the exact <strong>same</strong> theoretical field that Modanese calculates is
              <strong>buffering</strong>
              our nuclear fusion.
            </li>
          </ul>
          <p class="footnote">
            H. E. Puthoff, US Patent 5,845,220: "Communication method and apparatus with signals comprising scalar and
            vector potentials without electromagnetic fields" (1998)
          </p>
        </section>

        <!-- SLIDE: Direct Energy Conversion -->
        <section>
          <h2>The Aharonov-Bohm Antenna</h2>
          <p>How does Puthoff's patent extract energy from an invisible field?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              It relies on the <strong>Aharonov-Bohm Effect</strong>: an established quantum mechanical principle
              proving that an <strong>electron's phase</strong> will <strong>shift</strong> if it simply passes through
              a Vector Potential (<span>\( \mathbf{A} \)</span>), even if <strong>zero</strong>
              physical magnetic field is present.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Puthoff's circuits (using quantum interferometers) detect this phase shift and force
              <strong>electrons to flow(!)</strong>, creating an <strong>electrical current</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Grand Synthesis:</strong> If we embed Puthoff's Aharonov-Bohm antenna into Modanese's fusing
              Titanium lattice, the antenna bleeds the 24 MeV directly out of the standing wave as
              <strong>high-voltage Direct Current (DC)</strong>.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Cryogenic Hurdle -->
        <section>
          <h2>The Final Bottleneck: Cryogenics</h2>
          <p>There is one massive <strong>flaw</strong> in this combined architecture:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Puthoff’s most effective Aharonov-Bohm circuits require
              <strong>Josephson Junctions</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Josephson Junctions require <strong>superconductors</strong>, which only work at extreme cryogenic
              temperatures (liquid helium or nitrogen).
            </li>
            <li class="fragment fade-in-then-semi-out">
              You <strong>cannot</strong> put a liquid nitrogen cooling system inside <strong>consumer hardware</strong>
              like a smartphone battery, an electric vehicle, or a cheap residential power node.
            </li>
            <li class="fragment fade-in-then-semi-out">
              We need a <strong>room-temperature transducer</strong> to replace the superconductor.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Piezoelectric Workaround -->
        <section>
          <h2>Replacing the Circuit: Piezoelectricity</h2>
          <h3>(Insane Speculation)</h3>
          <p>Maybe we don't need a superconducting circuit if we have the right metamaterial:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Piezoelectric Materials</strong> possess a unique structural property: when subjected to internal
              <strong>mechanical stress</strong> (like acoustic phonons), the crystal physically deforms. (e.g. a
              Turntable Pickup)
            </li>
            <li class="fragment fade-in-then-semi-out">
              Because the crystal lattice is polarized, this deformation physically <strong>separates</strong>
              <em>positive</em> and <em>negative</em> charges, generating massive voltages at room temperature.
            </li>
            <li class="fragment fade-in-then-semi-out">
              If the fusing titanium lattice dumps its energy into intense <strong>phonon vibrations</strong>, a
              <strong>coupled</strong> piezoelectric crystal would "breathe" with the nuclear energy, instantly
              <strong>converting</strong> quantum vibrations into <strong>raw electricity</strong>.
            </li>
          </ul>
        </section>

        <!-- SLIDE: Archaeo-Mythology meets Physics -->
        <section>
          <h2>
            Engineered Quartz: <br />
            A Speculative Leap
          </h2>
          <p>
            What is the ultimate piezoelectric harmonic oscillator? <strong>Quartz (<span>\( SiO_2 \)</span>)</strong>.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Quartz already runs our modern computational clocks because it maintains
              <strong>perfect phase coherence</strong>. It is a macroscopic "harmonic qubit."
            </li>
            <li class="fragment fade-in-then-semi-out">
              Pure quartz lacks free electrons to screen (reduce) the Coulomb barrier.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Solution:</strong> Grow a synthetic metamaterial. A macro-quartz crystal internally doped with
              a Titanium-Hydride matrix.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <em>Mythological reference:</em> This theoretical architecture aligns eerily with "Atlantis" myths (the
              Tuaoi Stone/Firestone), which described massive, engineered crystals that harvested "cosmic energies" to
              <strong>wirelessly</strong> power civilizations.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Ultimate Solid-State Reactor -->
        <section>
          <h2>The Complete System Architecture</h2>
          <p>If we combine all these theories, the blueprint for the <strong>perfect reactor</strong> is:</p>
          <ol>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Fuel:</strong> Ordinary Hydrogen / Heavy Water (Abundant and cheap).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Engine:</strong> A Titanium-Hydride matrix triggered by thermal cycles (Gamberale).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Core Logic:</strong> Coherent QED standing waves orchestrate the PEP reaction and fusion
              (Modanese).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Buffer:</strong> The Vector Potential (<span>\( \mathbf{A} \)</span>) suppresses gamma rays
              and buffers the 24 MeV spike.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Power Supply:</strong> A surrounding Piezoelectric Quartz lattice acts as an <br />
              <strong>Aharonov-Bohm transducer</strong>, converting the <strong>scalar field</strong>
              directly into room-temperature
              <strong>electricity</strong>. <em>(Backup Plan: Puthoff)</em>
            </li>
          </ol>
        </section>

        <!-- CHAPTER: Implications -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Implications</h2>
          <p class="center-text">If it works, what changes?</p>
        </section>

        <!-- SLIDE: Why This Changes Everything -->
        <section>
          <h2>The Future of Energy</h2>
          <p>
            If this solid-state architecture proves viable, it renders current infrastructure <strong>obsolete</strong>.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Zero Radiation:</strong> No toxic waste, no lead shielding, no catastrophic meltdowns.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Infinite Scaling:</strong> No massive magnetic bottles. The reactor could be the size of a
              shipping container to power a city, or the <strong>size of a coin</strong> to power a laptop for a
              century.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Direct Energy:</strong> By bypassing the Carnot limit of heat,
              <strong>efficiency</strong> approaches near-theoretical maximums.
            </li>
            <li class="fragment fade-in-then-semi-out">
              It represents the <strong>ultimate mastery</strong> of the strong nuclear force through the elegance of
              <strong>solid-state quantum</strong> engineering.
            </li>
            <p class="fragment fade-in-then-semi-out">
              <em>
                (BTW: Probably all advanced civilizations would converge to this "<strong>Schelling Point</strong>".)
              </em>
            </p>
          </ul>
        </section>

        <!-- SLIDE: Conclusion -->
        <section>
          <h2>Conclusion: The Ultimate Upgrade</h2>
          <p>
            An advanced <strong>civilization</strong> does not power its future by setting things on
            <strong>fire</strong>, <strong>boiling water</strong>, or managing <strong>toxic waste</strong>. It masters
            the <strong>quantum fabric</strong> through elegant, solid-state architecture.
          </p>
          <p class="fragment fade-in-then-semi-out">
            The combined frameworks of <strong>Gamberale, Modanese, and Puthoff</strong> point directly to the
            <em>Holy Grail</em> of civilization‑scale engineering:
          </p>
          <div class="fragment fade-in-then-semi-out">
            <p class="center-text">
              <strong>direct, radiation-free, possibly wireless, infinite power.</strong>
            </p>
            <!--<p>Refuse primitive, brute-force APIs of the past. Choose the ultimate civilizational upgrade.</p>-->
          </div>
          <div class="fragment fade-in-then-semi-out">
            <p style="margin-top: 40px; font-size: 1.2em" class="highlight center-text">EOF</p>
            <p style="font-size: 0.8em" class="highlight center-text">Grazie.</p>
          </div>
        </section>
      </div>
      <div class="shortcut-legend" aria-label="Presentation shortcuts">
        <div class="shortcut-item is-on" data-shortcut="fragments" data-tooltip="press u to toggle fragments reveal">
          <span class="shortcut-key">u</span>
          <span class="shortcut-label">fragments</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="shimmer"
          data-scope="chapter"
          data-tooltip="press 1 to toggle phase shimmer"
        >
          <span class="shortcut-key">1</span>
          <span class="shortcut-label">phase shimmer</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="speckle"
          data-scope="chapter"
          data-tooltip="press 2 to toggle interference speckle"
        >
          <span class="shortcut-key">2</span>
          <span class="shortcut-label">interference speckle</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="wobble"
          data-scope="chapter"
          data-tooltip="press 3 to toggle micro wobble"
        >
          <span class="shortcut-key">3</span>
          <span class="shortcut-label">micro wobble</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="precession"
          data-scope="chapter"
          data-tooltip="press 4 to toggle vortex precession"
        >
          <span class="shortcut-key">4</span>
          <span class="shortcut-label">vortex precession</span>
        </div>
      </div>
    </div>

    <!-- The Vector Potential Standing Wave Filter -->
    <svg
      aria-hidden="true"
      focusable="false"
      style="position: absolute; width: 0; height: 0; overflow: hidden; left: -9999px; top: -9999px"
    >
      <filter id="vector-potential" x="-20%" y="-20%" width="140%" height="140%">
        <!-- Generate a low-frequency, fluid-like mathematical lattice structure -->
        <feTurbulence type="fractalNoise" baseFrequency="0.015 0.02" numOctaves="2" result="quantum_field" />
        <!-- Displace the slide (text + background) based on the field.
             The 'scale' is set to 0 initially, and will be animated by JS -->
        <feDisplacementMap
          id="wave-amplitude"
          in="SourceGraphic"
          in2="quantum_field"
          scale="0"
          xChannelSelector="R"
          yChannelSelector="G"
        />
      </filter>
    </svg>

    <!-- Reveal.js Scripts -->
    <script src="https://unpkg.com/reveal.js@5.2.1/dist/reveal.js"></script>
    <script src="https://unpkg.com/reveal.js@5.2.1/plugin/search/search.js"></script>

    <script>
      const applyChapterBackgrounds = () => {
        const chapters = document.querySelectorAll('.reveal .slides section.chapter')
        chapters.forEach((section) => {
          // Base: black
          section.setAttribute('data-background-color', '#000')
          section.setAttribute(
            'data-background-gradient',
            // Gradient: salmon -> headline -> lilac
            'linear-gradient(135deg, #fb8d80 0%, #42a5f5 40%, #42a5f5 60%, #857fda 100%)'
            //'linear-gradient(135deg, #fb8d80 0%, #000 40%, #000 60%, #857fda 100%)'
            //'linear-gradient(135deg, #071a2b 0%, #1a0730 55%, #0b3a3a 100%)'
          )
        })
      }

      applyChapterBackgrounds()

      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: 'c/t',
        showSlideNumber: 'all',
        center: true,
        hash: true,
        keyboard: {
          85: () => toggleFragments(), // u
          49: () => toggleQuantumEffect('shimmer'), // 1
          50: () => toggleQuantumEffect('speckle'), // 2
          51: () => toggleQuantumEffect('wobble'), // 3
          52: () => toggleQuantumEffect('precession'), // 4
          69: () => toggleQuantumLegend(), // e
        },
        fragments: false,
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        plugins: [RevealSearch],
      })

      const addUndimTriggers = () => {
        const sections = document.querySelectorAll('.reveal .slides section')
        sections.forEach((section) => {
          const fragments = section.querySelectorAll('.fragment')
          if (fragments.length === 0) return
          if (section.querySelector('.undim-trigger')) return

          let maxIndex = -1
          fragments.forEach((fragment) => {
            const rawIndex = fragment.getAttribute('data-fragment-index')
            if (rawIndex === null) return
            const parsedIndex = Number.parseInt(rawIndex, 10)
            if (!Number.isNaN(parsedIndex)) {
              maxIndex = Math.max(maxIndex, parsedIndex)
            }
          })

          const trigger = document.createElement('span')
          trigger.className = 'fragment undim-trigger'
          trigger.setAttribute('data-undim', 'true')
          trigger.style.display = 'none'
          if (maxIndex >= 0) {
            trigger.setAttribute('data-fragment-index', String(maxIndex + 1))
          }
          section.appendChild(trigger)
        })
      }

      const setUndimState = (section, enabled) => {
        if (!section) return
        if (enabled) {
          section.classList.add('undim')
        } else {
          section.classList.remove('undim')
        }
      }

      // Quantum effect toggles (default OFF). Flip these or use keys 1-4.
      const quantumEffects = {
        shimmer: true,
        speckle: false,
        wobble: true,
        precession: true,
      }

      const updateQuantumEffectClasses = () => {
        const revealEl = document.querySelector('.reveal')
        if (!revealEl) return
        revealEl.classList.toggle('effect-shimmer', quantumEffects.shimmer)
        revealEl.classList.toggle('effect-speckle', quantumEffects.speckle)
        revealEl.classList.toggle('effect-wobble', quantumEffects.wobble)
        revealEl.classList.toggle('effect-precession', quantumEffects.precession)
      }

      const toggleQuantumEffect = (effectKey) => {
        if (!(effectKey in quantumEffects)) return
        quantumEffects[effectKey] = !quantumEffects[effectKey]
        updateQuantumEffectClasses()
        updateShortcutLegend()
      }

      const updateShortcutLegend = () => {
        const fragmentItem = document.querySelector('.shortcut-item[data-shortcut="fragments"]')
        if (fragmentItem) {
          const enabled = Reveal.getConfig().fragments !== false
          fragmentItem.classList.toggle('is-on', enabled)
        }

        const effectItems = {
          shimmer: document.querySelector('.shortcut-item[data-shortcut="shimmer"]'),
          speckle: document.querySelector('.shortcut-item[data-shortcut="speckle"]'),
          wobble: document.querySelector('.shortcut-item[data-shortcut="wobble"]'),
          precession: document.querySelector('.shortcut-item[data-shortcut="precession"]'),
        }

        Object.entries(effectItems).forEach(([key, item]) => {
          if (!item) return
          item.classList.toggle('is-on', Boolean(quantumEffects[key]))
        })
      }

      const updateShortcutLegendVisibility = (section) => {
        const legend = document.querySelector('.shortcut-legend')
        if (!legend) return
        const hasFragments = Boolean(section && section.querySelector('.fragment'))
        const isChapter = Boolean(section && section.classList.contains('chapter'))

        const fragmentItem = legend.querySelector('.shortcut-item[data-shortcut="fragments"]')
        if (fragmentItem) {
          fragmentItem.classList.toggle('is-hidden', !hasFragments)
        }

        const chapterItems = legend.querySelectorAll('.shortcut-item[data-scope="chapter"]')
        chapterItems.forEach((item) => {
          item.classList.toggle('is-hidden', !isChapter)
        })

        const showChapterLegend = isChapter && quantumLegendVisible
        legend.classList.toggle('is-hidden', !hasFragments && !showChapterLegend)
        legend.classList.toggle('is-hidden-by-user', isChapter && !quantumLegendVisible)
      }

      const updateShortcutLegendPosition = () => {
        const legend = document.querySelector('.shortcut-legend')
        const slideNumber = document.querySelector('.reveal .slide-number')
        if (!legend || !slideNumber) return
        const rect = slideNumber.getBoundingClientRect()
        const gap = 8
        const right = Math.max(window.innerWidth - rect.left + gap, 40)
        const bottom = Math.max(window.innerHeight - rect.bottom, 10)
        legend.style.setProperty('--legend-right', `${right}px`)
        legend.style.setProperty('--legend-bottom', `${bottom}px`)
      }

      const toggleFragments = () => {
        const revealEl = document.querySelector('.reveal')
        const enabled = Reveal.getConfig().fragments !== false
        Reveal.configure({ fragments: !enabled })
        if (revealEl) {
          revealEl.classList.toggle('fragments-off', enabled)
        }
        updateShortcutLegend()
      }

      let quantumLegendVisible = false
      const toggleQuantumLegend = () => {
        const current = Reveal.getCurrentSlide()
        if (!current || !current.classList.contains('chapter')) return
        quantumLegendVisible = !quantumLegendVisible
        updateShortcutLegendVisibility(current)
      }

      const updateSlideNumberVisibility = (slide) => {
        const revealEl = document.querySelector('.reveal')
        if (!revealEl) return

        // Reveal's current slide can be temporarily null during startup.
        const resolvedSlide =
          slide || Reveal.getCurrentSlide() || document.querySelector('.reveal .slides section.present')
        if (!resolvedSlide) return

        const indices = Reveal.getIndices(resolvedSlide)
        const h = Number.isFinite(indices.h) ? indices.h : 0
        const v = Number.isFinite(indices.v) ? indices.v : 0
        const isFirstSlide = h === 0 && v === 0
        const isChapter = resolvedSlide.classList.contains('chapter')

        // Requested behavior:
        // - hide on all chapter/cover slides
        // - hide on the very first slide (h=0,v=0) even if it isn't a chapter cover
        const shouldHide = isFirstSlide || isChapter
        revealEl.classList.toggle('slide-number-hidden', shouldHide)
      }

      Reveal.on('ready', () => {
        addUndimTriggers()
        const revealEl = document.querySelector('.reveal')
        if (revealEl) {
          revealEl.classList.toggle('fragments-off', Reveal.getConfig().fragments === false)
        }
        updateQuantumEffectClasses()
        updateShortcutLegend()
        const currentSlide = Reveal.getCurrentSlide()
        updateShortcutLegendVisibility(currentSlide)
        updateSlideNumberVisibility(currentSlide)
        updateShortcutLegendPosition()

        // Ensure the slide counter is hidden on the initial slide after Reveal has finished laying out UI.
        setTimeout(() => updateSlideNumberVisibility(), 0)
      })

      Reveal.on('fragmentshown', (event) => {
        if (event.fragment && event.fragment.hasAttribute('data-undim')) {
          setUndimState(event.fragment.closest('section'), true)
        }
      })

      Reveal.on('fragmenthidden', (event) => {
        if (event.fragment && event.fragment.hasAttribute('data-undim')) {
          setUndimState(event.fragment.closest('section'), false)
        }
      })

      Reveal.on('slidechanged', (event) => {
        const trigger = event.currentSlide ? event.currentSlide.querySelector('.undim-trigger.visible') : null
        setUndimState(event.currentSlide, Boolean(trigger))
        updateShortcutLegendVisibility(event.currentSlide)
        updateSlideNumberVisibility(event.currentSlide)
        updateShortcutLegendPosition()
      })

      window.addEventListener('resize', () => {
        updateShortcutLegendPosition()
      })

      document.addEventListener('DOMContentLoaded', () => {
        const amplitudeEl = document.getElementById('wave-amplitude')
        let animationFrameId
        let startTime = null
        const amplitudePhasePrimary = Math.random() * Math.PI * 2
        const amplitudePhaseSecondary = Math.random() * Math.PI * 2
        const phaseDriftPhasePrimary = Math.random() * Math.PI * 2
        const phaseDriftPhaseSecondary = Math.random() * Math.PI * 2
        const microWavePhase = Math.random() * Math.PI * 2

        // The mathematical temporal oscillation of the standing wave
        function animateStandingWave(timestamp) {
          if (!startTime) startTime = timestamp
          const elapsed = timestamp - startTime

          // The math: Amplitude * sin(angular_frequency * time)
          // Divide elapsed by a large number (e.g., 3000) for a slow, 3-second meditative breathing.
          // Multiply by max displacement scale (e.g., 12 pixels).
          const WAVE_SCALE_PX = 7
          const WAVE_PERIOD_MS = 3000

          // Continuous noise modulation (smooth, never snaps).
          const AMPLITUDE_MOD_RANGE = 0.22 // Primary amplitude wobble (set to 0 to disable modulation).
          const AMPLITUDE_MOD_PERIOD_MS = 6200
          const AMPLITUDE_MOD_SECONDARY_RANGE = 0.13 // Secondary wobble (set to 0 to disable modulation).
          const AMPLITUDE_MOD_SECONDARY_PERIOD_MS = 11200
          const amplitudeMod =
            1 +
            AMPLITUDE_MOD_RANGE * Math.sin(amplitudePhasePrimary + (elapsed / AMPLITUDE_MOD_PERIOD_MS) * Math.PI * 2) +
            AMPLITUDE_MOD_SECONDARY_RANGE *
              Math.sin(amplitudePhaseSecondary + (elapsed / AMPLITUDE_MOD_SECONDARY_PERIOD_MS) * Math.PI * 2)

          // Continuous phase drift (keeps timing intact but adds organic wander).
          const PHASE_DRIFT_RANGE = 0.3 // Radians (set to 0 to disable phase drift).
          const PHASE_DRIFT_PERIOD_MS = 7400
          const PHASE_DRIFT_SECONDARY_RANGE = 0.15 // Radians (set to 0 to disable phase drift).
          const PHASE_DRIFT_SECONDARY_PERIOD_MS = 13200
          const phaseDrift =
            PHASE_DRIFT_RANGE * Math.sin(phaseDriftPhasePrimary + (elapsed / PHASE_DRIFT_PERIOD_MS) * Math.PI * 2) +
            PHASE_DRIFT_SECONDARY_RANGE *
              Math.sin(phaseDriftPhaseSecondary + (elapsed / PHASE_DRIFT_SECONDARY_PERIOD_MS) * Math.PI * 2)

          // Micro-wave texture layer (fixed period, random start phase for variation per load).
          const MICRO_WAVE_AMPLITUDE_PX = 1.6 // Set to 0 to disable the micro-wave layer.
          const MICRO_WAVE_PERIOD_MS = 2000
          const microWave =
            MICRO_WAVE_AMPLITUDE_PX * Math.sin(microWavePhase + (elapsed / MICRO_WAVE_PERIOD_MS) * Math.PI * 2)

          const mainWave = Math.sin(elapsed / WAVE_PERIOD_MS + phaseDrift)
          const currentScale = WAVE_SCALE_PX * amplitudeMod * mainWave + microWave

          amplitudeEl.setAttribute('scale', currentScale)

          animationFrameId = requestAnimationFrame(animateStandingWave)
        }

        const updateCoherentLattice = (slide) => {
          // Clean up: make sure the filter class is removed from previous slides
          document.querySelectorAll('.coherent-lattice-active').forEach((el) => {
            el.classList.remove('coherent-lattice-active')
          })

          let shouldAnimate = false
          if (slide) {
            const targets = slide.querySelectorAll('.coherent-lattice-target')
            if (targets.length > 0) {
              targets.forEach((el) => {
                el.classList.add('coherent-lattice-active')
              })
              shouldAnimate = true
            } else if (slide.classList.contains('chapter')) {
              // Fall back to full-slide effect for chapter covers
              slide.classList.add('coherent-lattice-active')
              const background = document.querySelector('.reveal .slide-background.present')
              if (background) {
                background.classList.add('coherent-lattice-active')
              }
              shouldAnimate = true
            }
          }

          if (shouldAnimate) {
            // Start the meditative breathing animation
            startTime = null
            if (animationFrameId) cancelAnimationFrame(animationFrameId)
            animationFrameId = requestAnimationFrame(animateStandingWave)
          } else if (animationFrameId) {
            // If we move away, pause animation to save CPU
            cancelAnimationFrame(animationFrameId)
          }
        }

        let rippleInterval

        // Function to generate a single random ripple
        function spawnQuantumRipple(container) {
          const ripple = document.createElement('div')
          ripple.classList.add('quantum-ripple')

          // Depth randomization toggles (OFF by default).
          // Flip any of these to `true` to experiment with the depth model.
          // When all are `false`, the vortex uses the CSS fallback values (no extra randomness).
          const ENABLE_DEPTH_SIZE = false // Randomly scales radius (near/far)
          const ENABLE_DEPTH_BLUR = false // Near = sharper, far = blurrier
          const ENABLE_DEPTH_CONTRAST = false // Near = higher contrast
          const ENABLE_DEPTH_OPACITY = false // Near = more visible at the peak
          const ENABLE_DEPTH_COLORS = false // Near = deeper/darker core + stronger highlights

          // Randomize position across the slide
          const x = Math.random() * 100
          const y = Math.random() * 100
          ripple.style.left = `${x}%`
          ripple.style.top = `${y}%`

          // Ripple base size (pixels)
          const RIPPLE_SIZE_MIN_PX = 10 // minimum diameter
          const RIPPLE_SIZE_JITTER_PX = 20 // random additional range (0..this)
          // Randomize the base size for a softer, larger vortex (min..min+jitter)
          const baseSize = RIPPLE_SIZE_MIN_PX + Math.random() * RIPPLE_SIZE_JITTER_PX
          ripple.style.width = `${baseSize}px`
          ripple.style.height = `${baseSize}px`

          const enableDepth =
            ENABLE_DEPTH_SIZE ||
            ENABLE_DEPTH_BLUR ||
            ENABLE_DEPTH_CONTRAST ||
            ENABLE_DEPTH_OPACITY ||
            ENABLE_DEPTH_COLORS

          if (enableDepth) {
            // Shared depth factor so all enabled properties feel coordinated.
            // Depth range: 0.7 (far) .. 1.4 (near)
            const depth = 0.7 + Math.random() * 0.7
            const depthNormalized = (depth - 0.7) / 0.7 // 0..1

            if (ENABLE_DEPTH_SIZE) {
              const size = baseSize * depth
              ripple.style.width = `${size}px`
              ripple.style.height = `${size}px`
            }

            if (ENABLE_DEPTH_BLUR) {
              const blur = 1.8 - depthNormalized * 0.7
              ripple.style.setProperty('--vortex-blur', `${blur.toFixed(2)}px`)
            }

            if (ENABLE_DEPTH_CONTRAST) {
              const contrast = 1.0 + depthNormalized * 0.22
              ripple.style.setProperty('--vortex-contrast', contrast.toFixed(2))
            }

            if (ENABLE_DEPTH_OPACITY) {
              const opacityMid = 0.35 + depthNormalized * 0.35
              ripple.style.setProperty('--vortex-opacity-mid', opacityMid.toFixed(2))
            }

            if (ENABLE_DEPTH_COLORS) {
              const core = 0.28 + depthNormalized * 0.18
              const inner = 0.18 + depthNormalized * 0.08
              const shadow = 0.18 + depthNormalized * 0.12
              const highlight = 0.22 + depthNormalized * 0.08
              const highlightStrong = 0.28 + depthNormalized * 0.1

              ripple.style.setProperty('--vortex-core', core.toFixed(2))
              ripple.style.setProperty('--vortex-inner', inner.toFixed(2))
              ripple.style.setProperty('--vortex-shadow', shadow.toFixed(2))
              ripple.style.setProperty('--vortex-highlight', highlight.toFixed(2))
              ripple.style.setProperty('--vortex-highlight-strong', highlightStrong.toFixed(2))
            }
          }

          // Ripple expansion timing (seconds)
          const EXPAND_DURATION_BASE_SECONDS = 0.7 // minimum base duration before scaling
          const EXPAND_DURATION_JITTER_SECONDS = 3 // random additional range (0..this)
          const EXPAND_DURATION_MULTIPLIER = 1.0 // global slow-down multiplier

          const expandDurationSeconds =
            (EXPAND_DURATION_BASE_SECONDS + Math.random() * EXPAND_DURATION_JITTER_SECONDS) * EXPAND_DURATION_MULTIPLIER
          ripple.style.setProperty('--expand-duration', `${expandDurationSeconds}s`)

          // Add it to the screen
          container.appendChild(ripple)

          // Garbage collection: remove the DOM element after animation finishes
          setTimeout(() => {
            if (container.contains(ripple)) {
              ripple.remove()
            }
          }, expandDurationSeconds * 1000)
        }

        const getRippleContainer = (slide) => {
          if (!slide) return null

          // Prefer the full-slide background layer when available
          const background = document.querySelector('.reveal .slide-background.present')
          let containerParent = slide
          if (background) {
            const backgroundContent = background.querySelector('.slide-background-content')
            containerParent = backgroundContent || background
          }

          let container = containerParent.querySelector('.quantum-ripple-container')
          if (!container) {
            container = document.createElement('div')
            container.classList.add('quantum-ripple-container')
            containerParent.appendChild(container)
          }

          return container
        }

        const updateQuantumRipples = (slide) => {
          // Clear old ripples if we leave the slide
          clearInterval(rippleInterval)

          if (!slide || !slide.classList.contains('chapter')) {
            return
          }

          const startRipples = () => {
            const container = getRippleContainer(slide)
            if (!container) return

            // Drop spawn rate controls
            const INITIAL_DROP_COUNT = 10 // how many drops appear shortly after entering a cover slide
            const INITIAL_DROP_SPREAD_MS = 2000 // spread those initial drops over 0..this window
            const DROP_INTERVAL_MS = 90 // steady-state rate: one drop per interval

            // 1. Spawn a couple of ripples immediately so the screen isn't empty
            for (let i = 0; i < INITIAL_DROP_COUNT; i++) {
              setTimeout(() => spawnQuantumRipple(container), Math.random() * INITIAL_DROP_SPREAD_MS)
            }

            // 2. Continuously spawn new ripples (e.g., one every 1.2 seconds)
            rippleInterval = setInterval(() => {
              const liveContainer = getRippleContainer(slide)
              if (liveContainer) {
                spawnQuantumRipple(liveContainer)
              }
            }, DROP_INTERVAL_MS)
          }

          // Delay to allow Reveal to finish background swaps during transitions
          requestAnimationFrame(() => {
            startRipples()
            setTimeout(() => {
              if (!rippleInterval) {
                startRipples()
              }
            }, 120)
          })
        }

        // Reveal.js event listener to start/stop the effect
        Reveal.on('slidechanged', (event) => {
          updateCoherentLattice(event.currentSlide)
          updateQuantumRipples(event.currentSlide)
        })

        // Apply on initial load as well
        updateCoherentLattice(Reveal.getCurrentSlide())
        updateQuantumRipples(Reveal.getCurrentSlide())
      })
    </script>
  </body>
</html>
