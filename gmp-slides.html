<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Solid-State Quantum Nuclear Energy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Reveal.js Base CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reset.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css" />
    <!-- Theme -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/sky.min.css" />

    <!-- CIA Google Fonts Fallback for rounded monospace font (theme does not import it) -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Sono:wght@400;700&display=swap" />

    <!-- Alternative primary Font Source (bypasses CIA Google Fonts/Gstatic issues) -->
    <!-- Browser naturally falls back to the theme's Google Fonts if this fails. -->
    <link
      rel="stylesheet"
      href="https://fonts.bunny.net/css?family=quicksand:400,700|open-sans:400,400i,700,700i|sono:400,700"
    />

    <!-- MathJax for rendering LaTeX formulas -->
    <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0&features=es7%2Ces6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>

    <style>
      .reveal h1,
      .reveal h2,
      .reveal h3 {
        color: #42a5f5;
        text-transform: none;
        margin-bottom: 20px;
      }
      .reveal h2 {
        font-size: 1.8em;
      }
      .reveal h3 {
        font-size: 1.2em;
      }
      .reveal code {
        font-family: 'Sono', monospace;
      }
      .highlight {
        color: rgb(250, 189, 46);
        font-weight: bold;
      }
      .reveal p,
      .reveal li {
        font-size: 0.58em;
        line-height: 1.5;
        text-align: left;
        margin-bottom: 15px;
      }
      .reveal section > ul > li {
        font-size: 0.55em;
      }
      .reveal section > ul > li > ul > li {
        font-size: 0.77em;
      }
      .reveal ul {
        display: block;
        margin-left: 5%;
        margin-right: 5%;
      }
      /* Footnote layout */
      .reveal section.has-footnote {
        display: block;
      }
      .reveal .progress {
        height: 10px;
      }
      .reveal .progress span {
        height: 100%;
      }
      .reveal .slide-number {
        font-size: 0.8em;
        padding: 6px 10px;
        background: rgba(0, 0, 0, 0.35);
        color: #fff;
        border-radius: 6px;
        right: 4em;
        bottom: 16px;
        transition: opacity 200ms ease;
        min-width: calc(5ch + 20px);
        text-align: center;
        box-sizing: border-box;
      }
      /* Hide the slide counter on chapter covers + the very first slide (JS toggles this class). */
      .reveal.slide-number-hidden .slide-number {
        opacity: 0;
        pointer-events: none;
      }
      /* Footnote styling */
      .footnote {
        position: relative;
        font-size: 0.4em !important;
        color: #aaa !important;
        text-align: left !important;
        border-top: 1px solid #555;
        padding-top: 6px;
        width: 90%;
        margin: 0 auto;
        line-height: 1.2 !important;
      }
      /* Center text helper */
      .center-text {
        text-align: center !important;
      }
      /* Chapter break slides */
      .reveal section.chapter {
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      .reveal section.chapter h2 {
        color: #fff;
        font-size: 2.2em;
        margin-bottom: 0.2em;
      }
      .reveal section.chapter p {
        color: rgba(255, 255, 255, 0.85) !important;
        text-align: center !important;
        font-size: 0.9em !important;
        margin: 0.2em 0 0 !important;
      }
      /* Undim all fragments on demand */
      .reveal.fragments-off .fragment,
      .reveal.fragments-off .fragment.visible,
      .reveal section.undim .fragment.visible {
        opacity: 1 !important;
      }
      /* Shortcut legend */
      .reveal .shortcut-legend {
        position: absolute;
        right: var(--legend-right, 6em);
        bottom: var(--legend-bottom, 16px);
        z-index: 30;
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 0.3em;
        pointer-events: auto;
      }
      .reveal .shortcut-legend.is-hidden {
        display: none;
      }
      .reveal .shortcut-legend.is-hidden-by-user {
        display: none;
      }
      .reveal .shortcut-item {
        position: relative;
        display: inline-flex;
        flex-direction: row;
        align-items: center;
        gap: 4px;
        padding: 2px 5px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.16);
        color: rgba(255, 255, 255, 0.6);
        transition:
          color 160ms ease,
          background 160ms ease,
          border-color 160ms ease;
        user-select: none;
      }
      .reveal .shortcut-item.is-on {
        color: #fff;
        background: rgba(0, 0, 0, 0.35);
      }
      .reveal .shortcut-item.is-on .shortcut-key {
        background: rgba(0, 0, 0, 0.35);
      }
      .reveal .shortcut-item.is-hidden {
        display: none;
      }
      .reveal .shortcut-key {
        display: inline-block;
        min-width: 0.9em;
        text-align: center;
        padding: 1px 4px;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.3);
        font-weight: 600;
        letter-spacing: 0.02em;
      }
      .reveal .shortcut-item::after {
        content: attr(data-tooltip);
        position: absolute;
        right: 0;
        bottom: calc(100% + 6px);
        padding: 6px 8px;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        font-size: 0.95em;
        white-space: nowrap;
        opacity: 0;
        transform: translateY(4px);
        transition:
          opacity 160ms ease,
          transform 160ms ease;
        pointer-events: none;
      }
      .reveal .shortcut-item:hover::after {
        opacity: 1;
        transform: translateY(0);
      }
      @property --vortex-spin {
        syntax: '<angle>';
        inherits: true;
        initial-value: 0deg;
      }
      @property --wobble-blur {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-x {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-y {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-x-fast {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-y-fast {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-x-slow {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-y-slow {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-blur-fast {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-blur-slow {
        syntax: '<length>';
        inherits: true;
        initial-value: 0px;
      }
      @property --wobble-contrast {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-contrast-fast {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-contrast-slow {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-strength {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-fast-mix {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --wobble-slow-mix {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --shimmer-phase {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --ripple-scale {
        syntax: '<number>';
        inherits: true;
        initial-value: 0;
      }
      @property --ripple-rotation {
        syntax: '<angle>';
        inherits: true;
        initial-value: 0deg;
      }
      .reveal {
        --shimmer-strength: 0;
        --speckle-strength: 0;
        --wobble-amount: 0px;
        --wobble-jitter: 0px;
        --wobble-contrast-amount: 0;
        --wobble-strength: 0;
        --wobble-filter-strength: 0;
        --precession-amount: 0deg;
        --wobble-fast-duration: 0.1s;
        --wobble-slow-duration: 0.6s;
        --wobble-echo-duration: 1s;
        --precession-duration: 5.2s;
        --shimmer-duration: 1.9s;
        --speckle-duration: 6.2s;
      }
      .reveal.effect-shimmer {
        --shimmer-strength: 0.85;
      }
      .reveal.effect-speckle {
        --speckle-strength: 0.55;
      }
      .reveal.effect-wobble {
        --wobble-amount: 2.1px;
        --wobble-jitter: 2px;
        --wobble-contrast-amount: 0.31;
        --wobble-strength: 1.2;
        --wobble-fast-duration: 0.1s;
        --wobble-slow-duration: 0.4s;
        --wobble-echo-duration: 0.6s;
      }
      .reveal.effect-wobble-filter {
        --wobble-filter-strength: 1.1;
      }
      .reveal.effect-precession {
        /* Rock amplitude (30% less than 72deg). */
        --precession-amount: 4.2deg;
        /* Rock speed: 0.2s period. */
        --precession-duration: 0.06s;
      }
      /* Effect 4 visibility: use a stronger blend mode without changing vortex color/alpha knobs. */
      .reveal.effect-precession .quantum-ripple {
        mix-blend-mode: overlay;
      }
      /* The class that triggers the Vector Potential distortion */
      .coherent-lattice-active {
        /* Apply the invisible SVG math to the whole slide */
        filter: url(#vector-potential);
        -webkit-filter: url(#vector-potential);

        /* Optional: slightly scale up to prevent edges from pulling inward during distortion */
        transform: scale(1.02);
      }
      .reveal .slide-background.present,
      .reveal .slide-background.present .slide-background-content {
        overflow: hidden;
      }
      .reveal .slide-background.present .slide-background-content {
        position: relative;
      }
      /* Container that holds the ripples behind the text but above the background */
      .quantum-ripple-container {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        z-index: 2; /* Ensure ripples render above slide backgrounds */
        pointer-events: none; /* Prevents it from interfering with clicks/swipes */
      }

      /* The Ripple Element */
      .quantum-ripple {
        position: absolute;
        border-radius: 50%;
        /* Vortex-like swirl that picks up background hues via blend mode */
        background:
          radial-gradient(
            circle at 50% 50%,
            rgba(0, 0, 0, var(--vortex-core, 0.38)) 0%,
            rgba(0, 0, 0, var(--vortex-inner, 0.2)) 28%,
            rgba(255, 255, 255, var(--vortex-highlight, 0.08)) 55%,
            rgba(255, 255, 255, 0) 75%
          ),
          conic-gradient(
            from var(--vortex-spin, 0deg),
            rgba(255, 255, 255, var(--vortex-highlight-strong, 0.34)),
            rgba(255, 255, 255, 0) 30%,
            rgba(0, 0, 0, var(--vortex-shadow, 0.26)) 54%,
            rgba(255, 255, 255, var(--vortex-highlight, 0.3)) 78%,
            rgba(255, 255, 255, var(--vortex-highlight-strong, 0.34))
          );
        background-blend-mode: multiply;
        mix-blend-mode: soft-light;
        box-shadow:
          inset 0 0 18px rgba(0, 0, 0, 0.28),
          0 0 14px rgba(255, 255, 255, 0.08);
        filter: blur(
            calc(
              var(--vortex-blur, 1.3px) + (var(--wobble-blur-fast, 0px) + var(--wobble-blur-slow, 0px)) *
                var(--wobble-filter-strength, 0)
            )
          )
          saturate(1.25)
          contrast(
            calc(
              var(--vortex-contrast, 1.12) + (var(--wobble-contrast-fast, 0) + var(--wobble-contrast-slow, 0)) *
                var(--wobble-filter-strength, 0)
            )
          )
          brightness(
            calc(
              1 +
                (
                  (var(--wobble-contrast-fast, 0) + var(--wobble-contrast-slow, 0)) * var(--wobble-filter-strength, 0) *
                    0.6
                )
            )
          );
        -webkit-mask: radial-gradient(
          circle,
          rgba(0, 0, 0, 0) 28%,
          rgba(0, 0, 0, 0.12) 36%,
          rgba(0, 0, 0, 0.82) 50%,
          rgba(0, 0, 0, 0.6) 70%,
          rgba(0, 0, 0, 0) 84%
        );
        mask: radial-gradient(
          circle,
          rgba(0, 0, 0, 0) 28%,
          rgba(0, 0, 0, 0.12) 36%,
          rgba(0, 0, 0, 0.82) 50%,
          rgba(0, 0, 0, 0.6) 70%,
          rgba(0, 0, 0, 0) 84%
        );
        transform: translate(
            calc(-50% + var(--wobble-x-fast, 0px) + var(--wobble-x-slow, 0px)),
            calc(-50% + var(--wobble-y-fast, 0px) + var(--wobble-y-slow, 0px))
          )
          scale(var(--ripple-scale, 0)) rotate(var(--ripple-rotation, 0deg));
        opacity: 0;
        /* Slower, smoother expansion */
        animation:
          expandRipple var(--expand-duration, 8s) var(--expand-easing, cubic-bezier(0.2, 0.6, 0.2, 1)) forwards,
          rippleWobbleFast var(--wobble-fast-duration, 0.1s) ease-in-out infinite,
          rippleWobbleSlow var(--wobble-slow-duration, 0.6s) ease-in-out infinite,
          rippleWobbleEcho var(--wobble-echo-duration, 1s) ease-out infinite,
          ripplePrecession var(--precession-duration, 5.2s) ease-in-out infinite;
      }
      /* Safari fallback: use direct transform keyframes instead of typed custom-property transform composition. */
      .reveal.legacy-ripple-transform .quantum-ripple {
        transform: translate(-50%, -50%) scale(0) rotate(0deg);
        animation:
          expandRippleLegacy var(--expand-duration, 8s) var(--expand-easing, cubic-bezier(0.2, 0.6, 0.2, 1)) forwards,
          rippleWobbleFast var(--wobble-fast-duration, 0.1s) ease-in-out infinite,
          rippleWobbleSlow var(--wobble-slow-duration, 0.6s) ease-in-out infinite,
          rippleWobbleEcho var(--wobble-echo-duration, 1s) ease-out infinite,
          ripplePrecession var(--precession-duration, 5.2s) ease-in-out infinite;
      }
      .quantum-ripple::before,
      .quantum-ripple::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 50%;
        pointer-events: none;
      }
      .quantum-ripple::before {
        background: inherit;
        mix-blend-mode: screen;
        filter: blur(0.8px);
        opacity: calc(var(--shimmer-strength, 0) * var(--shimmer-phase, 0));
        animation: rippleShimmer var(--shimmer-duration, 1.9s) ease-in-out infinite;
      }
      .quantum-ripple::after {
        background-image: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.85) 0px,
          rgba(255, 255, 255, 0.85) 1px,
          rgba(255, 255, 255, 0) 2.2px
        );
        background-size: 7px 7px;
        mix-blend-mode: screen;
        opacity: var(--speckle-strength, 0);
        filter: blur(0.6px);
        animation: speckleDrift var(--speckle-duration, 6.2s) linear infinite;
      }

      @keyframes expandRipple {
        0% {
          --ripple-scale: 0;
          --ripple-rotation: 0deg;
          opacity: var(--vortex-opacity-start, 0);
        }
        12% {
          --ripple-scale: 0.45;
          /* Swirl speed: reduce rotation to slow the vortex spin. */
          --ripple-rotation: 96deg;
          opacity: var(--vortex-opacity-mid, 0.55);
        }
        100% {
          --ripple-scale: 3.2;
          /* Swirl speed: total rotation amount (20% slower than before). */
          --ripple-rotation: 370deg;
          opacity: var(--vortex-opacity-end, 0);
        }
      }
      @keyframes expandRippleLegacy {
        0% {
          transform: translate(
              calc(-50% + var(--wobble-x-fast, 0px) + var(--wobble-x-slow, 0px)),
              calc(-50% + var(--wobble-y-fast, 0px) + var(--wobble-y-slow, 0px))
            )
            scale(0) rotate(0deg);
          opacity: var(--vortex-opacity-start, 0);
        }
        12% {
          transform: translate(
              calc(-50% + var(--wobble-x-fast, 0px) + var(--wobble-x-slow, 0px)),
              calc(-50% + var(--wobble-y-fast, 0px) + var(--wobble-y-slow, 0px))
            )
            scale(0.45) rotate(96deg);
          opacity: var(--vortex-opacity-mid, 0.55);
        }
        100% {
          transform: translate(
              calc(-50% + var(--wobble-x-fast, 0px) + var(--wobble-x-slow, 0px)),
              calc(-50% + var(--wobble-y-fast, 0px) + var(--wobble-y-slow, 0px))
            )
            scale(3.2) rotate(370deg);
          opacity: var(--vortex-opacity-end, 0);
        }
      }
      @keyframes rippleShimmer {
        0%,
        100% {
          --shimmer-phase: 0.2;
        }
        50% {
          --shimmer-phase: 1;
        }
      }
      @keyframes speckleDrift {
        0% {
          transform: translate(0, 0) scale(1);
        }
        50% {
          transform: translate(-6%, 4%) scale(1.02);
        }
        100% {
          transform: translate(4%, -5%) scale(1);
        }
      }
      @keyframes rippleWobbleFast {
        0%,
        100% {
          --wobble-blur-fast: calc(
            var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.5
          );
          --wobble-contrast-fast: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * 0.5
          );
          --wobble-x-fast: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.7
          );
          --wobble-y-fast: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * 0.5
          );
        }
        50% {
          --wobble-blur-fast: calc(var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0));
          --wobble-contrast-fast: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.4
          );
          --wobble-x-fast: calc(var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0));
          --wobble-y-fast: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-fast-mix, 0) * -0.8
          );
        }
      }
      @keyframes rippleWobbleSlow {
        0%,
        100% {
          --wobble-blur-slow: calc(
            var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.25
          );
          --wobble-contrast-slow: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.3
          );
          --wobble-x-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.45
          );
          --wobble-y-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.4
          );
        }
        50% {
          --wobble-blur-slow: calc(
            var(--wobble-amount, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.6
          );
          --wobble-contrast-slow: calc(
            var(--wobble-contrast-amount, 0) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.2
          );
          --wobble-x-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * -0.6
          );
          --wobble-y-slow: calc(
            var(--wobble-jitter, 0px) * var(--wobble-strength, 0) * var(--wobble-slow-mix, 0) * 0.5
          );
        }
      }
      @keyframes rippleWobbleEcho {
        0% {
          --wobble-fast-mix: 0;
          --wobble-slow-mix: 0;
        }
        6% {
          /* Sharp attack: fast strobe dominates immediately */
          --wobble-fast-mix: 1;
          --wobble-slow-mix: 0;
        }
        30% {
          /* Begin easing into the slower wobble */
          --wobble-fast-mix: 0.75;
          --wobble-slow-mix: 0.25;
        }
        60% {
          /* Sustained phase: slower wobble becomes the lead */
          --wobble-fast-mix: 0.35;
          --wobble-slow-mix: 0.6;
        }
        100% {
          /* Echo tail: mostly slow wobble, faint fast residue */
          --wobble-fast-mix: 0.15;
          --wobble-slow-mix: 0.8;
        }
      }
      @keyframes ripplePrecession {
        0%,
        100% {
          /* Effect 4: precession uses `rotate` (individual transform) so it composes with `transform`
             from `expandRipple` (no need to animate custom properties for visibility). */
          rotate: calc(var(--precession-amount, 0deg) * -1);
        }
        50% {
          rotate: var(--precession-amount, 0deg);
        }
      }

      /* Ambient background on normal slides */
      .ambient-gradient-bg {
        position: absolute;
        inset: 0;
        background-image: linear-gradient(135deg, #fb8d80 0%, #42a5f5 40%, #42a5f5 60%, #857fda 100%);
        opacity: 0;
        transition: opacity 0.5s ease;
        z-index: -1;
      }
      .reveal.effect-ambient .ambient-gradient-bg {
        opacity: 0.28;
      }
      .quantum-ripple-container.ambient-mode {
        --vortex-opacity-mid: 0;
        --vortex-opacity-start: 0;
        --vortex-opacity-end: 0;
      }
      .quantum-ripple-container.ambient-mode.debug-visible {
        --vortex-opacity-mid: 0.45;
      }
      .reveal.effect-ambient .quantum-ripple-container.ambient-mode {
        --vortex-opacity-mid: 0.45;
      }
      .vortex-debug-hud {
        position: fixed;
        left: 14px;
        top: 14px;
        z-index: 120;
        pointer-events: none;
        background: rgba(8, 10, 16, 0.82);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 8px;
        padding: 8px 10px;
        min-width: 240px;
        font-family: 'JetBrains Mono', 'Fira Code', 'SFMono-Regular', Menlo, Consolas, monospace;
        font-size: 11px;
        line-height: 1.35;
        color: #eaf3ff;
        white-space: pre-line;
      }
      .vortex-debug-hud.is-hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- SLIDE: Title -->
        <section>
          <h2>
            Solid-State <br />
            Quantum Nuclear Energy
          </h2>
          <h3>
            Bridging <em>Coherent QED</em> & <br />
            Direct Energy Extraction
          </h3>
          <div class="coherent-lattice-target">
            <p class="center-text" style="margin-top: 50px; font-size: 0.9em">
              <span>\( \mathbf{4E} \xrightarrow{\text{goes}} {}^4He \)</span>
            </p>
          </div>
        </section>

        <!-- CHAPTER: Motivation -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2>Motivation</h2>
          <p>Energy is breaking the build</p>
        </section>

        <!-- SLIDE: The Energy Problem -->
        <section>
          <h2>The Energy Stack is Broken</h2>
          <p>Humanity currently relies on outdated "APIs" to extract energy from nature:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Chemical (Fossil Fuels):</strong> Easy to access, but low energy density and highly polluting
              (carbon exhaust).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Nuclear Fission:</strong> High density, but leaves behind highly toxic state (radioactive waste)
              and risks catastrophic system crashes (meltdowns).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Hot Nuclear Fusion:</strong> The dream (Tokamaks/Stellarators). We try to hold a
              100-million-degree plasma star inside a magnetic bottle. It is a brute-force hardware solution that is
              notoriously unstable.
            </li>
          </ul>
          <p class="fragment fade-in-then-semi-out">
            <strong>The Question:</strong> Is there a more elegant, software-like approach to unlocking nuclear energy
            at <strong>room temperature</strong>?
          </p>
        </section>

        <!-- CHAPTER: whatis -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <code class="center-text">$ echo $TOPIC | xargs whatis</code>
        </section>

        <!-- SLIDE: Primer 1 - Solid-State vs Hot Fusion -->
        <section>
          <h2>The "Hardware" of Fusion</h2>
          <p>Redefining what a nuclear reactor looks like:</p>

          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Hot Fusion (The Vacuum Tube):</strong> We usually think of nuclear fusion as a 100-million-degree
              plasma trapped in giant magnetic bottles (Tokamaks). It is <strong>massive</strong>, <strong>hot</strong>,
              and highly <strong>unstable</strong>.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>Solid-State Physics:</strong> Just as computing moved from hot,
              <strong>fragile vacuum tubes</strong> to quiet, <strong>stable silicon microchips</strong>, physics is
              exploring the same transition for nuclear energy.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Metal Lattice:</strong> Instead of empty space and magnets, "<strong>Solid-State</strong>"
              means the reaction happens inside the rigid, geometric <strong>crystal structure</strong> (a lattice) of a
              metal, like Titanium.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Premise:</strong> We are looking at how a stable, room-temperature metal environment might be
              the key to <strong>confining</strong> and <strong>manipulating</strong> atoms without brute force.
            </li>
          </ul>
        </section>

        <!-- SLIDE: Primer 2 - Coherence and QED -->
        <section>
          <h2>
            The "Software" of the<br />
            Quantum Realm
          </h2>
          <p>To make solid-state fusion work, we rely on advanced quantum mechanics.</p>

          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Quantum Electrodynamics (QED):</strong> This is the fundamental
              <strong>physics framework</strong> describing how <strong>light</strong> (photons) and
              <strong>matter</strong> (electrons) <strong>interact</strong>. It is essentially the "source code" of
              electromagnetism.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>Execution Model:</strong> Normally, atoms in a metal <strong>vibrate randomly</strong> and
              <strong>independently</strong> (heat/chaos). They are <strong>asynchronous</strong> and disconnected.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>Quantum Coherence:</strong> Under highly specific conditions, millions of atoms in a lattice can
              <strong>synchronize</strong> their state, vibrating together in perfect <strong>phase</strong> like a
              laser.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Macroscopic State:</strong> When a lattice becomes "<strong><em>coherent</em></strong
              >", it stops acting as billions of individual atoms and begins acting as a single,
              <strong>unified quantum system</strong>.
            </li>

            <li class="fragment fade-in-then-semi-out">
              <strong>The Potential:</strong> This unified state may offer a mechanism to bypass extreme heat and deadly
              radiation, safely <strong>managing nuclear reactions</strong>.
            </li>
          </ul>
        </section>

        <!-- CHAPTER: Evidence -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Evidence</h2>
          <p class="center-text">A room-temperature nuclear anomaly</p>
        </section>

        <!-- SLIDE: The Inciting Incident -->
        <section class="has-footnote">
          <h2>The Titanium Hydride Anomaly</h2>
          <h3>(Experiment Result)</h3>
          <p>
            Since 2017, physicists <strong>L. Gamberale</strong> and <strong>G. Modanese</strong>
            have investigated anomalies in transition metals.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Setup:</strong> They take standard Titanium Hydride powders
              <span>\( (TiH_2) \)</span>—basically titanium metal heavily loaded with standard hydrogen gas.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Trigger:</strong> They subject it to simple thermal cycles (heating up and cooling down).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Observation:</strong> The system produces <strong>Deuterium</strong> <span>\( (D) \)</span>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Why is this groundbreaking? It suggests the lattice is not a passive container, but an
              <strong>active</strong> participant that <strong>orchestrates</strong> atomic bonding.
            </li>
          </ul>
          <p class="footnote">
            L. Gamberale, G. Modanese, "An Experimental Study on Deuterium Production from Titanium Hydride Powders
            Subjected to Thermal Cycles" (2024-11)
          </p>
        </section>

        <!-- SLIDE: The Physics Sanity Check -->
        <section>
          <h2>Why This <span class="highlight">MUST</span> Be Nuclear</h2>
          <p>
            Mainstream skeptics often dismiss these anomalies as "chemical errors." Here is why that is physically
            impossible:
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Energy Scale:</strong> Chemistry rearranges outer electrons (releasing a few
              <span>\( eV \)</span>). Creating Deuterium releases <span>\( \sim 1.44 \text{ MeV} \)</span>—a million
              times more energy.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Hardware Limitation / Missing Ingredient:</strong> Standard Hydrogen has 1 Proton. Deuterium
              has 1 Proton + <strong>1 Neutron</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Unbreakable Rule:</strong> Chemical reactions (Electromagnetic Force) only move electrons.
              They cannot touch the nucleus.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Altering Quarks:</strong> To get Deuterium from Hydrogen, a proton must physically be converted
              into a neutron. This strictly requires the <strong>Weak Nuclear Force</strong> to flip quarks. Chemistry
              is fundamentally incapable of this.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Conclusion:</strong> A nuclear event is definitively happening in a <strong>low-energy</strong>,
              solid-state environment. (aka. <em>Cold Fusion</em>, <em>LENR</em>)
            </li>
          </ul>
        </section>

        <!-- SLIDE: The "Missing Death" Mystery -->
        <section>
          <h2>
            The Mystery:<br />
            Where is the Radiation?
          </h2>
          <p>If a nuclear reaction is happening on a laboratory bench, why aren't the researchers dead?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              In standard vacuum physics, generating Deuterium and fusing it produces high-energy
              <strong>gamma rays</strong> and <strong>rogue neutrons</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              A rogue neutron is like a memory leak in a computer system—it penetrates surrounding materials, corrupting
              their atomic structure and making them highly radioactive.
            </li>
            <li class="fragment fade-in-then-semi-out">
              However, in these specific Titanium experiments, Geiger counters detect
              <strong>zero deadly radiation</strong>.
            </li>
          </ul>
          <p class="fragment fade-in-then-semi-out">
            How does the system successfully process a <strong>nuclear transaction</strong> without emitting<br />
            <strong>toxic matter</strong> "data corruption"?
          </p>
        </section>

        <!-- CHAPTER: Mechanism -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Mechanism</h2>
          <p class="center-text">Nuclear, but (maybe) radiation-free</p>
        </section>

        <!-- SLIDE: Phase 0 - The Setup -->
        <section>
          <h2>
            Phase 0: The Solid-State<br />
            Pre-Processor
          </h2>
          <p>How the metal lattice prepares the physical environment for fusion:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Fuel (Protons):</strong> Hydrogen (<span>\( p^+ + e^- \)</span>) gas is absorbed into the
              Titanium. The atoms split, locking <strong>bare protons</strong> inside the crystal's microscopic
              <strong>gaps</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Environment (Electrons):</strong> Titanium's metallic "<em>conduction band</em>" (outermost
              electron shells overlap) provides a massive, shared pool of highly mobile,<br />
              <strong>free-floating electrons</strong> (like a fluid).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Charge Encapsulation (Coulomb suppression)</strong>: The dense electron cloud encapsulates the
              trapped protons, <strong>nullifying</strong> their positive <strong>repulsion</strong> so they can
              physically interface/touch.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Trigger (Thermal Cycles):</strong> Heating and cooling causes sudden structural phase
              transitions. The violently shifting lattice briefly <strong>clusters</strong> protons and electrons into
              <strong>ultra-dense</strong> micro-environments, triggering fusion.
            </li>
          </ul>
        </section>

        <!-- SLIDE: Phase 1: The PEP Reaction -->
        <section>
          <h2>Phase 1: The Neutrino Offload Sink</h2>
          <p>
            To create Deuterium (<span>\( p^+n^0 + e^- \)</span>) without radiation, the system utilizes<br />
            "<em>Electron Capture</em>" in a three-body interaction known as the <strong>PEP Reaction</strong>:
          </p>
          <p class="center-text highlight fragment fade-in"><span>\( p + e^- + p \rightarrow D + \nu_e \)</span></p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Atomic Transaction:</strong> Turning a proton into a neutron <strong>costs</strong> energy,
              forming a nucleus releases <strong>energy</strong>. The system resolves this by executing both
              <strong>simultaneously</strong> as one quantum <strong>transaction</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Execution:</strong> <strong>Proton A</strong> absorbs one electron (goes neutron) and
              instantly binds with <strong>Proton B</strong>. The output is a
              <strong>Deuteron nucleus (<span>\( D \)</span>)</strong> and a tiny
              <strong>neutrino (<span>\( \nu_e \)</span>)</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Sink:</strong> This transaction yields a <span>\( 1.44 \text{ MeV} \)</span> energy gain.
              Because the Deuteron is heavy and slow, the rules of momentum dictate the nearly massless neutrino takes
              ~99.9% of the energy.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Result:</strong> The neutrino <strong>safely</strong> exits Earth at near light-speed,
              removing the massive energy spike without triggering lethal radiation.
            </li>
          </ul>
        </section>

        <!-- VISUAL SLIDE: The PEP Reaction (Phase 1) -->
        <section>
          <h2>Visualizing the PEP Reaction</h2>
          <svg class="r-stretch" viewBox="0 0 1000 450" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <!-- Quantum Glows -->
              <filter id="glow-proton" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="4" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
              </filter>
              <filter id="glow-electron" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="6" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
              </filter>
              <filter id="glow-neutrino" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="3" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
              </filter>
              <!-- Energy Flash -->
              <radialGradient id="flashGradient" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#fff" stop-opacity="1" />
                <stop offset="40%" stop-color="#b026ff" stop-opacity="0.8" />
                <stop offset="100%" stop-color="#111c29" stop-opacity="0" />
              </radialGradient>

              <!-- Arrow Markers -->
              <marker
                id="arrow-cyan"
                viewBox="0 0 10 10"
                refX="5"
                refY="5"
                markerWidth="6"
                markerHeight="6"
                orient="auto-start-reverse"
              >
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#00e5ff" />
              </marker>
              <marker
                id="arrow-red"
                viewBox="0 0 10 10"
                refX="5"
                refY="5"
                markerWidth="6"
                markerHeight="6"
                orient="auto-start-reverse"
              >
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#ff4444" />
              </marker>
            </defs>

            <g transform="translate(50, 40)">
              <rect width="900" height="360" rx="10" fill="#111c29" stroke="#555" stroke-width="2" />

              <!-- Pipeline Dividers -->
              <line x1="300" y1="0" x2="300" y2="360" stroke="#333" stroke-width="2" stroke-dasharray="6" />
              <line x1="600" y1="0" x2="600" y2="360" stroke="#333" stroke-width="2" stroke-dasharray="6" />

              <!-- STEP 1: INPUT / ENCAPSULATION -->
              <text
                x="150"
                y="40"
                fill="#aaa"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
                letter-spacing="1"
              >
                1. CHARGE ENCAPSULATION
              </text>

              <!-- The Encapsulation Shell (The proxy bounding box) -->
              <rect
                x="100"
                y="70"
                width="100"
                height="220"
                rx="50"
                fill="none"
                stroke="#00e5ff"
                stroke-width="3"
                stroke-dasharray="6,4"
                filter="url(#glow-electron)"
              />
              <text
                x="150"
                y="60"
                fill="#00e5ff"
                font-family="sans-serif"
                font-size="12"
                font-weight="bold"
                text-anchor="middle"
              >
                Neutralized Domain
              </text>

              <!-- Dense e- cloud in the center -->
              <circle cx="150" cy="180" r="35" fill="#00e5ff" opacity="0.2" filter="url(#glow-electron)" />
              <circle cx="150" cy="180" r="10" fill="#00e5ff" opacity="0.8" filter="url(#glow-electron)" />
              <text
                x="150"
                y="184"
                fill="#fff"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
              >
                e⁻
              </text>

              <!-- Top Proton -->
              <circle cx="150" cy="115" r="16" fill="#ff4444" filter="url(#glow-proton)" />
              <text
                x="150"
                y="120"
                fill="#fff"
                font-family="sans-serif"
                font-size="16"
                font-weight="bold"
                text-anchor="middle"
              >
                p⁺
              </text>

              <!-- Bottom Proton -->
              <circle cx="150" cy="245" r="16" fill="#ff4444" filter="url(#glow-proton)" />
              <text
                x="150"
                y="250"
                fill="#fff"
                font-family="sans-serif"
                font-size="16"
                font-weight="bold"
                text-anchor="middle"
              >
                p⁺
              </text>

              <!-- Repulsion Blocked (Red lines hitting the shell and failing) -->
              <path
                d="M 150 90 L 150 75"
                fill="none"
                stroke="#ff4444"
                stroke-width="3"
                opacity="0.6"
                marker-end="url(#arrow-red)"
              />
              <line x1="140" y1="75" x2="160" y2="75" stroke="#ff4444" stroke-width="3" opacity="0.8" />
              <!-- Blocked symbol -->

              <path
                d="M 150 270 L 150 285"
                fill="none"
                stroke="#ff4444"
                stroke-width="3"
                opacity="0.6"
                marker-end="url(#arrow-red)"
              />
              <line x1="140" y1="285" x2="160" y2="285" stroke="#ff4444" stroke-width="3" opacity="0.8" />
              <!-- Blocked symbol -->

              <!-- Encapsulation Pull (Cyan arrows showing the barrier is bypassed) -->
              <path
                d="M 100 135 Q 110 150 135 160"
                fill="none"
                stroke="#00e5ff"
                stroke-width="2"
                marker-end="url(#arrow-cyan)"
              />
              <path
                d="M 100 225 Q 110 210 135 200"
                fill="none"
                stroke="#00e5ff"
                stroke-width="2"
                marker-end="url(#arrow-cyan)"
              />

              <text x="150" y="310" fill="#fff" font-family="sans-serif" font-size="14" text-anchor="middle">
                Electron pool suppreses
              </text>
              <text x="150" y="325" fill="#fff" font-family="sans-serif" font-size="14" text-anchor="middle">
                the Coulomb barrier
              </text>

              <!-- STEP 2: PROCESSING / THE WEAK INTERACTION -->
              <text
                x="450"
                y="40"
                fill="#aaa"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
                letter-spacing="1"
              >
                2. ELECTRON CAPTURE & FUSION-TX
              </text>

              <!-- The Flash -->
              <circle cx="450" cy="180" r="70" fill="url(#flashGradient)" />

              <!-- Merging Particles -->
              <circle cx="435" cy="180" r="16" fill="#ff4444" filter="url(#glow-proton)" />
              <!-- p+ -->
              <circle cx="465" cy="180" r="16" fill="#00e5ff" filter="url(#glow-electron)" />
              <!-- e- -->
              <circle cx="450" cy="150" r="16" fill="#ff4444" filter="url(#glow-proton)" />
              <!-- p+ -->

              <text
                x="450"
                y="310"
                fill="#b026ff"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
              >
                Proton A absorbs electron,
              </text>
              <text
                x="450"
                y="325"
                fill="#b026ff"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
              >
                converts to Neutron, binds Proton B.
              </text>

              <!-- STEP 3: OUTPUT / THE SINK -->
              <text
                x="750"
                y="40"
                fill="#aaa"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
                letter-spacing="1"
              >
                3. SAFE OUTPUT
              </text>

              <!-- Deuteron Nucleus (Proton + Neutron) -->
              <circle cx="680" cy="180" r="20" fill="#ff4444" filter="url(#glow-proton)" />
              <text
                x="680"
                y="185"
                fill="#fff"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
              >
                p⁺
              </text>
              <circle cx="715" cy="180" r="20" fill="#888" filter="url(#glow-proton)" />
              <text
                x="715"
                y="185"
                fill="#fff"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
              >
                n⁰
              </text>

              <!-- Deuterium Label -->
              <text
                x="697"
                y="225"
                fill="#fff"
                font-family="sans-serif"
                font-size="16"
                font-weight="bold"
                text-anchor="middle"
              >
                Deuteron (D)
              </text>

              <!-- Neutrino Ray Shooting off -->
              <path
                d="M 740 180 Q 750 165 760 180 T 780 180 T 800 180 T 820 180 T 840 180 T 860 180"
                fill="none"
                stroke="#00ffcc"
                stroke-width="3"
                filter="url(#glow-neutrino)"
              />
              <!-- Arrowhead for Neutrino -->
              <polygon points="858,172 875,180 858,188" fill="#00ffcc" filter="url(#glow-neutrino)" />

              <text
                x="800"
                y="160"
                fill="#00ffcc"
                font-family="sans-serif"
                font-size="16"
                font-weight="bold"
                text-anchor="middle"
              >
                Neutrino (νe)
              </text>

              <text
                x="750"
                y="310"
                fill="#00ffcc"
                font-family="sans-serif"
                font-size="14"
                font-weight="bold"
                text-anchor="middle"
              >
                Carries ~99.9% of the 1.44 MeV
              </text>
              <text x="750" y="325" fill="#fff" font-family="sans-serif" font-size="14" text-anchor="middle">
                safely out of the crystal at light-speed.
              </text>
            </g>
          </svg>
        </section>

        <!-- SLIDE: Phase 2: The 24 MeV Problem -->
        <section class="has-footnote">
          <h2>Phase 2: The 24 MeV Problem</h2>
          <h3>(Theory)</h3>
          <p>Creating Deuterium is safe, but as it accumulates, the <strong>Deuterons fuse</strong> together:</p>
          <p class="center-text highlight fragment fade-in">
            <span>\( D + D \rightarrow {}^4He + 24 \text{ MeV} \)</span>
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              In standard physics, this specific fusion emits a lethal
              <span>\( 24 \text{ MeV} \)</span> <strong>gamma ray</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              To explain the lack of gamma rays, Modanese relies on the legacy of<br />
              <strong>Giuliano Preparata</strong> and the theory of
              <strong>Coherent Quantum Electrodynamics (QED)</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Concept:</strong> Atoms in a tight crystalline lattice do not act as independent agents. They
              exchange photons so rapidly they enter a "<em>superradiant</em>" <strong>synchronized</strong> state.
            </li>
          </ul>
          <p class="footnote">G. Modanese, "Coherent Plasma in a Lattice" (2022-05)</p>
        </section>

        <!-- SLIDE: Unpacking Superradiance -->
        <section>
          <h2>
            Superradiance:<br />
            The actual "Magic" Engine
          </h2>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Asynchronous Reality:</strong> Normally, atoms act like independent, isolated threads. Their
              energy capacity scales linearly (<span>\( N \)</span>).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Synchronization:</strong> In a dense, structured lattice, atoms can
              <strong>couple</strong> (<em>entangle</em>) to the exact <strong>same</strong> electromagnetic field,
              locking into perfect <strong>phase</strong>. (Robert Dicke)
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The "Macro-Atom":</strong> They stop behaving as billions of individual particles and merge into a
              single, <strong>unified quantum</strong> execution loop.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Exponential Scaling:</strong> Because they are perfectly synchronized, their capacity to absorb
              and emit energy suddenly (to exchange with the electromagnetic field)
              <strong>scales</strong> exponentially (<span>\( N^2 \)</span>).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Payoff:</strong> This is the only mechanism that allows a crystal to
              <strong>instantly swallow</strong> a <span>\( 24 \text{ MeV} \)</span> nuclear spike without
              <strong>vaporizing</strong>.
            </li>
          </ul>
          <p class="footnote">R. H. Dicke, "Coherence in Spontaneous Radiation Processes" (1954)</p>
        </section>

        <!-- VISUAL SLIDE: Superradiance -->
        <section>
          <h2>Visualizing Superradiance</h2>
          <svg class="r-stretch" viewBox="0 0 1000 450" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <!-- Quantum Glow Filter -->
              <filter id="glow-strong" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="6" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
              </filter>
              <filter id="glow-subtle" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="3" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
              </filter>
            </defs>

            <!-- LEFT PANEL: ASYNCHRONOUS -->
            <g transform="translate(50, 50)">
              <rect width="400" height="350" rx="10" fill="#15151a" stroke="#444" stroke-width="2" />
              <text
                x="200"
                y="40"
                fill="#ff4444"
                font-family="sans-serif"
                font-size="20"
                font-weight="bold"
                text-anchor="middle"
                letter-spacing="1"
              >
                ASYNCHRONOUS (Standard)
              </text>
              <text x="200" y="65" fill="#aaa" font-family="sans-serif" font-size="16" text-anchor="middle">
                Linear Scaling: Capacity ∝ N
              </text>

              <!-- Chaotic, localized energy spikes -->
              <path
                d="M 80 180 Q 120 120 150 160 T 200 130"
                fill="none"
                stroke="#ff4444"
                stroke-width="3"
                filter="url(#glow-strong)"
                opacity="0.8"
              />
              <path
                d="M 220 250 Q 260 300 300 240 T 350 280"
                fill="none"
                stroke="#ff4444"
                stroke-width="3"
                filter="url(#glow-strong)"
                opacity="0.8"
              />
              <path
                d="M 280 130 L 330 180 L 250 160"
                fill="none"
                stroke="#ff4444"
                stroke-width="3"
                filter="url(#glow-strong)"
                opacity="0.8"
              />

              <!-- Randomly scattered atoms -->
              <circle cx="80" cy="180" r="8" fill="#555" />
              <circle cx="150" cy="160" r="10" fill="#ff4444" filter="url(#glow-strong)" />
              <!-- Hot node -->
              <circle cx="200" cy="130" r="8" fill="#555" />
              <circle cx="100" cy="280" r="8" fill="#555" />
              <circle cx="220" cy="250" r="10" fill="#ff4444" filter="url(#glow-strong)" />
              <!-- Hot node -->
              <circle cx="300" cy="240" r="8" fill="#555" />
              <circle cx="350" cy="280" r="10" fill="#ff4444" filter="url(#glow-strong)" />
              <!-- Hot node -->
              <circle cx="280" cy="130" r="8" fill="#555" />
              <circle cx="250" cy="180" r="8" fill="#555" />

              <text x="200" y="320" fill="#ff4444" font-family="sans-serif" font-size="14" text-anchor="middle">
                Local nodes overload and rupture
              </text>

              <!-- Legend -->
              <g transform="translate(15, 360)">
                <circle cx="0" cy="0" r="5" fill="#555" />
                <text x="10" y="4" fill="#aaa" font-family="sans-serif" font-size="12">Node</text>

                <circle cx="65" cy="0" r="5" fill="#ff4444" filter="url(#glow-strong)" />
                <text x="75" y="4" fill="#aaa" font-family="sans-serif" font-size="12">Overload</text>

                <path d="M 145 0 L 165 0" stroke="#ff4444" stroke-width="3" filter="url(#glow-strong)" />

                <path
                  d="M 0 25 Q 10 17 20 25 T 40 25"
                  fill="none"
                  stroke="#ff4444"
                  stroke-width="2"
                  filter="url(#glow-strong)"
                />
                <text x="50" y="25" fill="#aaa" font-family="sans-serif" font-size="12">Propagating Photons</text>
                <text x="50" y="39" fill="#aaa" font-family="sans-serif" font-size="12">
                  with radiative Dissipation (Energy Transfer)
                </text>
              </g>
            </g>

            <!-- RIGHT PANEL: SYNCHRONOUS -->
            <g transform="translate(550, 50)">
              <rect width="400" height="350" rx="10" fill="#0d1b2a" stroke="#00e5ff" stroke-width="2" />
              <text
                x="200"
                y="40"
                fill="#00e5ff"
                font-family="sans-serif"
                font-size="20"
                font-weight="bold"
                text-anchor="middle"
                letter-spacing="1"
              >
                SYNCHRONOUS (Coherent)
              </text>
              <text x="200" y="65" fill="#aaa" font-family="sans-serif" font-size="16" text-anchor="middle">
                Exponential Scaling: Capacity ∝ N²
              </text>

              <!-- Lattice Lines -->
              <g stroke="#00e5ff" stroke-width="1" opacity="0.2">
                <line x1="80" y1="140" x2="320" y2="140" />
                <line x1="80" y1="200" x2="320" y2="200" />
                <line x1="80" y1="260" x2="320" y2="260" />
                <line x1="80" y1="140" x2="80" y2="260" />
                <line x1="140" y1="140" x2="140" y2="260" />
                <line x1="200" y1="140" x2="200" y2="260" />
                <line x1="260" y1="140" x2="260" y2="260" />
                <line x1="320" y1="140" x2="320" y2="260" />
              </g>

              <!-- Macroscopic Standing Wave -->
              <path
                d="M 40 200 Q 120 100 200 200 T 360 200"
                fill="none"
                stroke="#00e5ff"
                stroke-width="6"
                filter="url(#glow-strong)"
                opacity="0.9"
              />

              <!-- Ordered Grid Atoms -->
              <g fill="#00e5ff" filter="url(#glow-subtle)">
                <circle cx="80" cy="140" r="6" />
                <circle cx="140" cy="140" r="6" />
                <circle cx="200" cy="140" r="6" />
                <circle cx="260" cy="140" r="6" />
                <circle cx="320" cy="140" r="6" />
                <circle cx="80" cy="200" r="6" />
                <circle cx="140" cy="200" r="6" />
                <circle cx="200" cy="200" r="6" />
                <circle cx="260" cy="200" r="6" />
                <circle cx="320" cy="200" r="6" />
                <circle cx="80" cy="260" r="6" />
                <circle cx="140" cy="260" r="6" />
                <circle cx="200" cy="260" r="6" />
                <circle cx="260" cy="260" r="6" />
                <circle cx="320" cy="260" r="6" />
              </g>

              <text x="200" y="320" fill="#00e5ff" font-family="sans-serif" font-size="14" text-anchor="middle">
                Nodes merge into a unified "Macro-Atom"
              </text>

              <!-- Legend -->
              <g transform="translate(15, 360)">
                <circle cx="0" cy="0" r="5" fill="#00e5ff" filter="url(#glow-subtle)" />
                <text x="10" y="4" fill="#aaa" font-family="sans-serif" font-size="12">Coherent Node</text>

                <path
                  d="M 0 25 Q 10 17 20 25 T 40 25"
                  fill="none"
                  stroke="#00e5ff"
                  stroke-width="3"
                  filter="url(#glow-strong)"
                />
                <text x="50" y="25" fill="#aaa" font-family="sans-serif" font-size="12">
                  Macroscopic Standing Wave in (A)
                </text>
                <text x="50" y="39" fill="#aaa" font-family="sans-serif" font-size="12">
                  with thermal Dissipation (Energy Transfer)
                </text>
              </g>
            </g>
          </svg>
        </section>

        <!-- CHAPTER: Potentials -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Potentials</h2>
          <p class="center-text">
            Why <span>\( \mathbf{A} \)</span> can matter even when <span>\( \mathbf{E}, \mathbf{B} = 0 \)</span>
          </p>
        </section>

        <!-- SLIDE: Explaining Maxwell (Frontend vs Backend) -->
        <section>
          <h2>
            Electromagnetism:<br />
            Frontend vs. Backend
          </h2>
          <p>Let's review Maxwell’s equations of electromagnetism:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The "Frontend" Observable API:</strong> The Electric Field (<span>\( \mathbf{E} \)</span>) and
              Magnetic Field (<span>\( \mathbf{B} \)</span>). These are the physical forces we measure. They push
              electrons around. Standard antennas, radios, and gamma rays are just oscillating
              <span>\( \mathbf{E} \)</span> and <span>\( \mathbf{B} \)</span> fields.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The "Backend" Underlying State:</strong> To calculate <span>\( \mathbf{E} \)</span> and
              <span>\( \mathbf{B} \)</span>, physicists use two deeper mathematical constructs:
              <ul>
                <li>
                  The <strong>Scalar Potential (<span>\( \phi \)</span>)</strong>: Think of this like electric pressure
                  or voltage—a single number at a specific point in space.
                </li>
                <li>
                  The <strong>Vector Potential (<span>\( \mathbf{A} \)</span>)</strong>: A directional flow field.
                  <!-- prettier-ignore -->
                  Mathematically, the magnetic field is just a derivative of this underlying state
                  (<span>\( \mathbf{B} = \nabla \times \mathbf{A} \)</span>).
                </li>
              </ul>
            </li>
            <li class="fragment fade-in-then-semi-out">
              In 19th-century classical physics, <span>\( \mathbf{A} \)</span> and <span>\( \phi \)</span> were
              considered mere <br />
              "helper variables"—useful for math, but lacking physical reality.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Quantum Reality (Aharonov-Bohm) -->
        <section>
          <h2>
            The Quantum Reality:<br />
            The Source Code
          </h2>
          <p>
            The <strong>Aharonov-Bohm effect</strong> (1959) proved that <span>\( \mathbf{A} \)</span> and
            <span>\( \phi \)</span> are the <em>true</em> primary reality.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Proof:</strong> Electrons passing through a space with zero force
              <!--prettier-ignore -->
              (<span>\( \mathbf{E} = 0 \)</span>, <span>\( \mathbf{B} = 0 \)</span>),<br />
              but a <strong>non-zero</strong> Vector Potential (<span>\( \mathbf{A} \)</span>) still physically
              <strong>shift their quantum phase</strong> (wave state).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Analogy:</strong> <span>\( \mathbf{E} \)</span> and <span>\( \mathbf{B} \)</span> are just the
              rendered UI. <span>\( \mathbf{A} \)</span> and <span>\( \phi \)</span> are the backend database. You can
              alter the backend state without rendering a UI.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Why this matters:</strong> To suppress a <span>\( 24 \text{ MeV} \)</span> gamma ray, the lattice
              writes energy directly to the <span>\( \mathbf{A} \)</span>-field backend, entirely
              <strong>bypassing</strong> the deadly <span>\( \mathbf{E} \)</span>/<span>\( \mathbf{B} \)</span> "UI".
            </li>
          </ul>
          <p class="footnote">
            Y. Aharonov, D. Bohm, "Significance of Electromagnetic Potentials in the Quantum Theory" (1959)
          </p>
        </section>

        <!-- SLIDE: The Buffer -->
        <section>
          <h2>
            The Vector Potential (<span>\( \mathbf{A} \)</span>)<br />
            as a Quantum Buffer
          </h2>
          <p>
            The <em>superradiant</em> state generates a macroscopic electromagnetic <strong>standing wave</strong> in
            the <strong>Vector Potential (<span>\( \mathbf{A} \)</span>)</strong>.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              When <span>\( D + D \)</span> fuses, the massive <span>\( 24 \text{ MeV} \)</span> energy payload is
              <strong>not</strong> localized to a single atom.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Instead, it is instantly distributed into the macroscopic
              <strong>Vector Potential (<span>\( \mathbf{A} \)</span>) standing wave</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Because the collective field <strong>absorbs</strong> the payload, the violent
              <strong>gamma-ray photon</strong> is never allowed to "compile". The lattice acts as an infinite energy
              buffer.
            </li>
          </ul>
        </section>

        <!-- VISUAL SLIDE: Vector Potential Buffering -->
        <section>
          <h2>The <span>\( \mathbf{A} \)</span>-Field in Action</h2>
          <svg class="r-stretch" viewBox="0 0 1000 450" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="glow-massive" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="12" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
              </filter>
              <filter id="glow-wave" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="5" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
              </filter>
              <!-- Gradient showing energy shifting from cold lattice to hot buffered energy -->
              <linearGradient id="heatGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="#00e5ff" />
                <stop offset="30%" stop-color="#b026ff" />
                <stop offset="50%" stop-color="#ff267e" />
                <stop offset="70%" stop-color="#b026ff" />
                <stop offset="100%" stop-color="#00e5ff" />
              </linearGradient>
            </defs>

            <g transform="translate(100, 40)">
              <rect width="800" height="360" rx="10" fill="#111c29" stroke="#555" stroke-width="2" />

              <!-- Lattice lines (distorted near the center) -->
              <g stroke="#00e5ff" stroke-width="2" opacity="0.3">
                <!-- Horizontals -->
                <line x1="100" y1="120" x2="700" y2="120" />
                <path d="M 100 180 Q 400 160 700 180" fill="none" />
                <path d="M 100 240 Q 400 260 700 240" fill="none" />
                <line x1="100" y1="300" x2="700" y2="300" />

                <!-- Verticals -->
                <line x1="150" y1="80" x2="150" y2="320" />
                <line x1="250" y1="80" x2="250" y2="320" />
                <path d="M 350 80 Q 330 200 350 320" fill="none" />
                <path d="M 450 80 Q 470 200 450 320" fill="none" />
                <line x1="550" y1="80" x2="550" y2="320" />
                <line x1="650" y1="80" x2="650" y2="320" />
              </g>

              <!-- The Global Buffer Wave (A-Field) absorbing the shock -->
              <path
                d="M 50 200 Q 200 50 400 200 T 750 200"
                fill="none"
                stroke="url(#heatGradient)"
                stroke-width="15"
                filter="url(#glow-wave)"
                opacity="0.8"
              />
              <path
                d="M 50 200 Q 200 50 400 200 T 750 200"
                fill="none"
                stroke="#fff"
                stroke-width="4"
                filter="url(#glow-wave)"
                opacity="0.9"
              />

              <!-- Lattice Nodes -->
              <g fill="#00e5ff" filter="url(#glow-wave)">
                <!-- Cool Outer Nodes -->
                <circle cx="150" cy="120" r="6" />
                <circle cx="250" cy="120" r="6" />
                <circle cx="550" cy="120" r="6" />
                <circle cx="650" cy="120" r="6" />
                <circle cx="150" cy="176.9" r="6" />
                <circle cx="250" cy="172.5" r="6" />
                <circle cx="550" cy="172.5" r="6" />
                <circle cx="650" cy="176.9" r="6" />
                <circle cx="150" cy="243.1" r="6" />
                <circle cx="250" cy="247.5" r="6" />
                <circle cx="550" cy="247.5" r="6" />
                <circle cx="650" cy="243.1" r="6" />
                <circle cx="150" cy="300" r="6" />
                <circle cx="250" cy="300" r="6" />
                <circle cx="550" cy="300" r="6" />
                <circle cx="650" cy="300" r="6" />
              </g>

              <!-- Warmed inner nodes distributing the heat -->
              <g fill="#b026ff" filter="url(#glow-wave)">
                <circle cx="344.4" cy="120" r="7" />
                <circle cx="455.6" cy="120" r="7" />
                <circle cx="340.6" cy="170.4" r="8" />
                <circle cx="459.4" cy="170.4" r="8" />
                <circle cx="341.7" cy="249.6" r="8" />
                <circle cx="458.3" cy="249.6" r="8" />
                <circle cx="346.9" cy="300" r="7" />
                <circle cx="453.1" cy="300" r="7" />
              </g>

              <!-- THE FUSION EVENT IN THE CENTER -->
              <circle cx="400" cy="200" r="15" fill="#fff" filter="url(#glow-massive)" />
              <circle cx="400" cy="200" r="8" fill="#ff267e" />

              <!-- Annotation Lines and Labels -->
              <!-- Pointing to fusion -->
              <line x1="400" y1="180" x2="400" y2="70" stroke="#fff" stroke-width="2" stroke-dasharray="4" />
              <text
                x="400"
                y="55"
                fill="#fff"
                font-family="sans-serif"
                font-size="16"
                font-weight="bold"
                text-anchor="middle"
              >
                D + D FUSION (24 MeV)
              </text>

              <!-- Pointing to the Buffer Wave -->
              <line x1="580" y1="260" x2="680" y2="315" stroke="#fff" stroke-width="2" stroke-dasharray="4" />
              <text
                x="680"
                y="335"
                fill="#ff267e"
                font-family="sans-serif"
                font-size="16"
                font-weight="bold"
                text-anchor="middle"
              >
                Energy instantly uploaded
              </text>
              <text x="680" y="350" fill="#ff267e" font-family="sans-serif" font-size="14" text-anchor="middle">
                to the Vector Potential (A)
              </text>

              <text
                x="360"
                y="345"
                fill="#00e5ff"
                font-family="sans-serif"
                font-size="16"
                font-weight="bold"
                text-anchor="middle"
                letter-spacing="1"
              >
                GAMMA RAY COMPLETELY SUPPRESSED
              </text>

              <!-- Legend (Top Left) -->
              <g transform="translate(20, 20)">
                <line x1="0" y1="0" x2="20" y2="0" stroke="#00e5ff" stroke-width="2" opacity="0.4" />
                <line x1="10" y1="-10" x2="10" y2="10" stroke="#00e5ff" stroke-width="2" opacity="0.4" />
                <text x="25" y="4" fill="#aaa" font-family="sans-serif" font-size="12">
                  Electromagnetic Binding Forces
                </text>
              </g>
            </g>
          </svg>
        </section>

        <!-- SLIDE: Scalar Fields & Safety -->
        <section class="has-footnote">
          <h2>
            Why Doesn't the Energy<br />
            Destroy the Lattice?
          </h2>
          <p>If the lattice absorbs <span>\( 24 \text{ MeV} \)</span>, why doesn't it just instantly vaporize?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Standard electromagnetic waves (like radio or light) are "transverse" and cause rapid
              <strong>dissipation</strong> (destructive).
            </li>
            <li class="fragment fade-in-then-semi-out">
              Modanese proves mathematically that transient nuclear currents inside a coherent lattice generate
              <strong>scalar (or longitudinal) electromagnetic fields</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Scalar fields have a unique property: they <em>cannot</em> radiate away into free space. It acts like a
              <strong>perfect</strong>, <strong>lossless superconductor</strong> (<em>quantum capacitor</em>) for the
              energy.
            </li>
            <li class="fragment fade-in-then-semi-out">
              The energy is <strong>safely trapped</strong>, "sloshing" back and forth inside the medium without
              destroying the physical structure.
            </li>
          </ul>
          <p class="footnote">
            G. Modanese, "Aharonov-Bohm electrodynamics in material media: a scalar e.m. field cannot cause dissipation
            in a medium" (2023-02)
          </p>
        </section>

        <!-- SLIDE: Harmonic Qubits -->
        <section class="has-footnote">
          <h2>
            Translating Quantum Slosh<br />
            into Safe Heat
          </h2>
          <p>How does the system finally bleed off this trapped energy?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              The authors model the atoms of the lattice as <strong>Harmonic Qubits</strong> connected by long-range
              photon coupling.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This allows for a process called "<em>superradiant</em> decay."
            </li>
            <li class="fragment fade-in-then-semi-out">
              Instead of <strong>1 atom</strong> vibrating with <strong>24,000,000</strong>
              <span>\( \text{eV} \)</span> of energy (which means it explodes), the standing wave forces
              <strong>1,000,000,000 atoms</strong> to vibrate <strong>simultaneously</strong> (coherence) with
              <strong>0.024</strong> <span>\( \text{eV} \)</span> of energy.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Result:</strong> The <strong>massive nuclear payload</strong> is safely dispersed as
              macroscopic <em>acoustic</em> vibrations (Phonons). We experience this simply as pure, continuous
              <strong>Heat</strong>.
            </li>
          </ul>
          <p class="footnote">
            L. Gamberale, G. Modanese, "Excited states of coherent harmonic qubits with long-range photon coupling and
            dissipation" (2025-02)
          </p>
        </section>

        <!-- SLIDE: The Failsafe -->
        <section>
          <h2>The Ultimate Built-In Thermostat</h2>
          <p>Why <strong>can't</strong> this system cause a <strong>nuclear meltdown</strong> like Chernobyl?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              The entire reaction is entirely dependent on the <strong>phase coherence</strong> of the lattice.
            </li>
            <li class="fragment fade-in-then-semi-out">
              If the reaction produces heat too quickly, the titanium lattice physically expands.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This expansion <strong>breaks</strong> the precise geometry required for the standing wave. The
              <strong>Coherent Plasma collapses</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Without the Vector Potential (<span>\( \mathbf{A} \)</span>), the
              <strong>Coulomb barrier</strong> instantly <strong>returns</strong>, and the nuclear fusion
              <strong>halts</strong>. It is a physically <strong>un-hackable, self-regulating</strong> system.
            </li>
          </ul>
        </section>

        <!-- CHAPTER: Engineering -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Engineering</h2>
          <p class="center-text">Turning buffered energy into usable electricity</p>
        </section>

        <!-- SLIDE: The Engineering Bottleneck -->
        <section>
          <h2>
            The Next Problem: <br />
            Heat is Inefficient
          </h2>
          <p>
            If Modanese and Gamberale are right, we have a perfect solid-state heat generator. But heat is a terrible
            "API" for modern technology.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              To turn heat into electricity, we still rely on 19th-century technology:<br />
              <strong>boiling water</strong> to create steam to physically spin a massive magnetic turbine.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This is bottlenecked by the <strong>Carnot Limit</strong> (thermodynamic inefficiency). <br />
              We <strong>lose over 60%</strong> of the energy just in the conversion process.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Ultimate Engineering Goal:</strong> Can we extract the energy
              <em>while it is still trapped in the Vector Potential (<span>\( \mathbf{A} \)</span>)</em>, completely
              bypassing the generation of heat?
            </li>
          </ul>
        </section>

        <!-- SLIDE: Enter Hal Puthoff -->
        <section class="has-footnote">
          <h2>The Missing Circuit: Hal Puthoff</h2>
          <h3>(Patent)</h3>
          <p>
            To extract energy from the Vector Potential (<span>\( \mathbf{A} \)</span>), we must look to another <br />
            pioneer of advanced physics: <strong>Dr. Harold E. Puthoff</strong>.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Standard antennas (like Wi-Fi) only interact with oscillating
              <!-- prettier-ignore -->
              Electric (<span>\( \mathbf{E} \)</span>) and<br />
              Magnetic (<span>\( \mathbf{B} \)</span>) fields.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Puthoff designed and patented specialized <strong>quantum circuits</strong> designed specifically to
              <em>transmit</em> and <em>receive</em> signals (wireless) using <strong>only</strong> the <br />
              <strong>Vector Potential (<span>\( \mathbf{A} \)</span>)</strong>
              and <strong>Scalar Potential (<span>\( \phi \)</span>)</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              This is the exact <strong>same</strong> theoretical field that Modanese calculates is
              <strong>buffering</strong>
              our nuclear fusion.
            </li>
          </ul>
          <p class="footnote">
            H. E. Puthoff, US Patent 5,845,220: "Communication method and apparatus with signals comprising scalar and
            vector potentials without electromagnetic fields" (1998)
          </p>
        </section>

        <!-- SLIDE: Direct Energy Conversion -->
        <section>
          <h2>The Aharonov-Bohm Antenna</h2>
          <p>How does Puthoff's patent extract energy from an invisible field?</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              It relies on the <strong>Aharonov-Bohm Effect</strong>: an established quantum mechanical principle
              proving that an <strong>electron's phase</strong> will <strong>shift</strong> if it simply passes through
              a Vector Potential (<span>\( \mathbf{A} \)</span>), even if <strong>zero</strong>
              physical magnetic field is present.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Puthoff's circuits (using quantum interferometers) detect this phase shift and force
              <strong>electrons to flow(!)</strong>, creating an <strong>electrical current</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Grand Synthesis:</strong> If we embed Puthoff's Aharonov-Bohm antenna into Modanese's fusing
              Titanium lattice, the antenna bleeds the <span>\( 24 \text{ MeV} \)</span> directly out of the standing
              wave as <strong>high-voltage Direct Current (DC)</strong>.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Cryogenic Hurdle -->
        <section>
          <h2>The Final Bottleneck: Cryogenics</h2>
          <p>There is one massive <strong>flaw</strong> in this combined architecture:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Puthoff’s most effective Aharonov-Bohm circuits require
              <strong>Josephson Junctions</strong>.
            </li>
            <li class="fragment fade-in-then-semi-out">
              Josephson Junctions require <strong>superconductors</strong>, which only work at extreme cryogenic
              temperatures (liquid helium or nitrogen).
            </li>
            <li class="fragment fade-in-then-semi-out">
              You <strong>cannot</strong> put a liquid nitrogen cooling system inside <strong>consumer hardware</strong>
              like a smartphone battery, an electric vehicle, or a cheap residential power node.
            </li>
            <li class="fragment fade-in-then-semi-out">
              We need a <strong>room-temperature transducer</strong> to replace the superconductor.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Piezoelectric Workaround -->
        <section>
          <h2>Replacing the Circuit: Piezoelectricity</h2>
          <h3>(Insane Speculation)</h3>
          <p>Maybe we don't need a superconducting circuit if we have the right metamaterial:</p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Piezoelectric Materials</strong> possess a unique structural property: when subjected to internal
              <strong>mechanical stress</strong> (like acoustic phonons), the crystal physically deforms. (e.g. a
              Turntable Pickup)
            </li>
            <li class="fragment fade-in-then-semi-out">
              Because the crystal lattice is polarized, this deformation physically <strong>separates</strong>
              <em>positive</em> and <em>negative</em> charges, generating massive voltages at room temperature.
            </li>
            <li class="fragment fade-in-then-semi-out">
              If the fusing titanium lattice dumps its energy into intense <strong>phonon vibrations</strong>, a
              <strong>coupled</strong> piezoelectric crystal would "breathe" with the nuclear energy, instantly
              <strong>converting</strong> quantum vibrations into <strong>raw electricity</strong>.
            </li>
          </ul>
        </section>

        <!-- SLIDE: Archaeo-Mythology meets Physics -->
        <section>
          <h2>
            Engineered Quartz: <br />
            A Speculative Leap
          </h2>
          <p>
            What is the ultimate piezoelectric harmonic oscillator? <strong>Quartz (<span>\( SiO_2 \)</span>)</strong>.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              Quartz already runs our modern computational clocks because it maintains
              <strong>perfect phase coherence</strong>. It is a macroscopic "harmonic qubit."
            </li>
            <li class="fragment fade-in-then-semi-out">
              Pure quartz lacks free electrons to screen (reduce) the Coulomb barrier.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Solution:</strong> Grow a synthetic metamaterial. A macro-quartz crystal internally doped with
              a Titanium-Hydride matrix.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <em>Mythological reference:</em> This theoretical architecture aligns eerily with "Atlantis" myths (the
              Tuaoi Stone/Firestone), which described massive, engineered crystals that harvested "cosmic energies" to
              <strong>wirelessly</strong> power civilizations.
            </li>
          </ul>
        </section>

        <!-- SLIDE: The Ultimate Solid-State Reactor -->
        <section>
          <h2>The Complete System Architecture</h2>
          <p>If we combine all these theories, the blueprint for the <strong>perfect reactor</strong> is:</p>
          <ol>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Fuel:</strong> Ordinary Hydrogen / Heavy Water (<strong>abundant</strong> and
              <strong>cheap</strong>).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Engine:</strong> A Titanium-Hydride matrix triggered by
              <strong>thermal cycles</strong> (Gamberale).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Core Logic:</strong> Coherent QED standing waves orchestrate the
              <strong>PEP reaction</strong> and fusion (Modanese).
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Buffer:</strong> The Vector Potential (<span>\( \mathbf{A} \)</span>) suppresses gamma rays
              and buffers the <span>\( 24 \text{ MeV} \)</span> spike.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>The Power Supply:</strong> A surrounding Piezoelectric Quartz lattice acts as an <br />
              <strong>Aharonov-Bohm transducer</strong>, converting the <strong>scalar field</strong> directly into<br />
              <strong>room-temperature</strong> electricity. <em>(Backup Plan: Puthoff)</em>
            </li>
          </ol>
        </section>

        <!-- CHAPTER: Implications -->
        <section class="chapter" data-transition="fade" data-slide-number="false">
          <h2 class="center-text">Implications</h2>
          <p class="center-text">If it works, what changes?</p>
        </section>

        <!-- SLIDE: Why This Changes Everything -->
        <section>
          <h2>The Future of Energy</h2>
          <p>
            If this solid-state architecture proves viable, it renders current infrastructure <strong>obsolete</strong>.
          </p>
          <ul>
            <li class="fragment fade-in-then-semi-out">
              <strong>Zero Radiation:</strong> No toxic waste, no lead shielding, no catastrophic meltdowns.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Infinite Scaling:</strong> No massive magnetic bottles. The reactor could be the size of a
              shipping container to power a city, or the <strong>size of a coin</strong> to power a laptop for a
              century.
            </li>
            <li class="fragment fade-in-then-semi-out">
              <strong>Direct Energy:</strong> By bypassing the Carnot limit of heat,
              <strong>efficiency</strong> approaches near-theoretical maximums.
            </li>
            <li class="fragment fade-in-then-semi-out">
              It represents the <strong>ultimate mastery</strong> of the strong nuclear force through the elegance of
              <strong>solid-state quantum</strong> engineering.
            </li>
            <p class="fragment fade-in-then-semi-out">
              <em>
                (BTW: Probably all advanced civilizations would converge to this "<strong>Schelling Point</strong>".)
              </em>
            </p>
          </ul>
        </section>

        <!-- SLIDE: Conclusion -->
        <section>
          <h2>Conclusion: The Ultimate Upgrade</h2>
          <p>
            An advanced <strong>civilization</strong> does not power its future by setting things on
            <strong>fire</strong>, <strong>boiling water</strong>, or managing <strong>toxic waste</strong>. It masters
            the <strong>quantum fabric</strong> through elegant, solid-state architecture.
          </p>
          <p class="fragment fade-in-then-semi-out">
            The combined frameworks of <strong>Gamberale</strong>, <strong>Modanese</strong>, and
            <strong>Puthoff</strong> point directly to the <em>Holy Grail</em> of civilization‑scale engineering:
          </p>
          <div class="fragment fade-in-then-semi-out">
            <p class="center-text">
              <strong>direct, radiation-free, possibly wireless, infinite power.</strong>
            </p>
            <!--<p>Refuse primitive, brute-force APIs of the past. Choose the ultimate civilizational upgrade.</p>-->
          </div>
          <div class="fragment fade-in-then-semi-out">
            <p style="margin-top: 40px; font-size: 1.2em" class="highlight center-text">EOF</p>
            <p style="font-size: 0.8em" class="highlight center-text">Grazie.</p>
          </div>
        </section>
      </div>

      <div class="shortcut-legend" aria-label="Presentation shortcuts">
        <div class="shortcut-item is-on" data-shortcut="fragments" data-tooltip="press s to toggle fragments reveal">
          <span class="shortcut-key">s</span>
          <span class="shortcut-label">fragments</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="ambient"
          data-scope="normal"
          data-tooltip="press a to toggle ambient mode"
        >
          <span class="shortcut-key">a</span>
          <span class="shortcut-label">ambient</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="shimmer"
          data-scope="chapter"
          data-tooltip="press 1 to toggle phase shimmer"
        >
          <span class="shortcut-key">1</span>
          <span class="shortcut-label">phase shimmer</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="speckle"
          data-scope="chapter"
          data-tooltip="press 2 to toggle interference speckle"
        >
          <span class="shortcut-key">2</span>
          <span class="shortcut-label">interference speckle</span>
        </div>
        <div class="shortcut-item" data-shortcut="wobble" data-scope="chapter" data-tooltip="press 3 to toggle wobble">
          <span class="shortcut-key">3</span>
          <span class="shortcut-label">wobble</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="wobble-filter"
          data-scope="chapter"
          data-tooltip="press 4 to toggle wobble blur/contrast filter path"
        >
          <span class="shortcut-key">4</span>
          <span class="shortcut-label">wobble filter</span>
        </div>
        <div
          class="shortcut-item"
          data-shortcut="precession"
          data-scope="chapter"
          data-tooltip="press 5 to toggle vortex precession"
        >
          <span class="shortcut-key">5</span>
          <span class="shortcut-label">vortex precession</span>
        </div>

        <div
          class="shortcut-item"
          data-shortcut="debug"
          data-scope="chapter"
          data-tooltip="press d to toggle deterministic vortex debug mode"
        >
          <span class="shortcut-key">d</span>
          <span class="shortcut-label">debug</span>
        </div>
        <div class="shortcut-item" data-shortcut="hud" data-scope="chapter" data-tooltip="press x to toggle debug HUD">
          <span class="shortcut-key">x</span>
          <span class="shortcut-label">hud</span>
        </div>
      </div>
    </div>

    <!-- The Vector Potential Standing Wave Filter -->
    <svg
      aria-hidden="true"
      focusable="false"
      style="position: absolute; width: 0; height: 0; overflow: hidden; left: -9999px; top: -9999px"
    >
      <filter id="vector-potential" x="-20%" y="-20%" width="140%" height="140%">
        <!-- Generate a low-frequency, fluid-like mathematical lattice structure -->
        <feTurbulence type="fractalNoise" baseFrequency="0.015 0.02" numOctaves="2" result="quantum_field" />
        <!-- Displace the slide (text + background) based on the field.
             The 'scale' is set to 0 initially, and will be animated by JS -->
        <feDisplacementMap
          id="wave-amplitude"
          in="SourceGraphic"
          in2="quantum_field"
          scale="0"
          xChannelSelector="R"
          yChannelSelector="G"
        />
      </filter>
    </svg>

    <!-- Reveal.js Scripts -->
    <script src="https://unpkg.com/reveal.js@5.2.1/dist/reveal.js"></script>
    <script src="https://unpkg.com/reveal.js@5.2.1/plugin/search/search.js"></script>

    <script>
      const applyChapterBackgrounds = () => {
        const sections = document.querySelectorAll('.reveal .slides > section')
        sections.forEach((section, index) => {
          if (index === 0) return // Skip title slide

          if (section.classList.contains('chapter')) {
            // Base: black
            section.setAttribute('data-background-color', '#000')
            section.setAttribute(
              'data-background-gradient',
              // Gradient: salmon -> headline -> lilac
              'linear-gradient(135deg, #fb8d80 0%, #42a5f5 40%, #42a5f5 60%, #857fda 100%)'
            )
          }
        })
      }

      applyChapterBackgrounds()

      Reveal.initialize({
        controls: true,
        progress: true,
        slideNumber: 'c/t',
        showSlideNumber: 'all',
        center: true,
        hash: true,
        keyboard: {
          65: () => toggleAmbientMode(), // a
          68: () => toggleVortexDebugMode(), // d
          88: () => toggleDebugHudMode(), // x
          83: () => toggleFragments(), // s
          49: () => toggleQuantumEffect('shimmer'), // 1
          50: () => toggleQuantumEffect('speckle'), // 2
          51: () => toggleQuantumEffect('wobble'), // 3
          52: () => toggleQuantumEffect('wobbleFilter'), // 4
          53: () => toggleQuantumEffect('precession'), // 5
          69: () => toggleQuantumLegend(), // e
        },
        fragments: false,
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        plugins: [RevealSearch],
      })

      const addUndimTriggers = () => {
        const sections = document.querySelectorAll('.reveal .slides section')
        sections.forEach((section) => {
          const fragments = section.querySelectorAll('.fragment')
          if (fragments.length === 0) return
          if (section.querySelector('.undim-trigger')) return

          const trigger = document.createElement('span')
          trigger.className = 'fragment undim-trigger'
          trigger.setAttribute('data-undim', 'true')
          trigger.style.display = 'none'
          section.appendChild(trigger)
        })
        if (typeof Reveal.sync === 'function') {
          Reveal.sync()
        }
      }

      const setUndimState = (section, enabled) => {
        if (!section) return
        if (enabled) {
          section.classList.add('undim')
        } else {
          section.classList.remove('undim')
        }
      }

      // Ambient mode state for normal slides
      let ambientMode = false
      let vortexDebugMode = false
      let debugHudEnabled = false
      const VORTEX_DEBUG_MARGIN_PX = 200
      const VORTEX_DEBUG_DURATION_SECONDS = 5
      const VORTEX_DEBUG_RESPAWN_GAP_MS = 100
      const VORTEX_DEBUG_MIN_RADIUS_PX = 100
      const isSafariLikely = (() => {
        const ua = navigator.userAgent
        return /Safari\//.test(ua) && !/(Chrome|CriOS|Chromium|Edg|OPR|FxiOS|Firefox)/.test(ua)
      })()
      if (isSafariLikely) {
        const revealRoot = document.querySelector('.reveal')
        if (revealRoot) {
          revealRoot.classList.add('legacy-ripple-transform')
        }
      }

      const toggleAmbientMode = () => {
        ambientMode = !ambientMode
        const revealEl = document.querySelector('.reveal')
        if (revealEl) {
          revealEl.classList.toggle('effect-ambient', ambientMode)
        }
        updateShortcutLegend()
        // Dispatch event so that updateCoherentLattice (defined inside DOMContentLoaded) can react
        document.dispatchEvent(new CustomEvent('toggleAmbient'))
      }

      const toggleVortexDebugMode = () => {
        vortexDebugMode = !vortexDebugMode
        updateShortcutLegend()
        document.dispatchEvent(new CustomEvent('toggleVortexDebug'))
      }

      const toggleDebugHudMode = () => {
        debugHudEnabled = !debugHudEnabled
        updateShortcutLegend()
        document.dispatchEvent(new CustomEvent('toggleDebugHud'))
      }

      // Quantum effect toggles (default OFF). Flip these or use keys 1-4.
      const quantumEffects = {
        shimmer: true,
        speckle: false,
        wobble: true,
        wobbleFilter: true,
        precession: true,
      }

      const updateQuantumEffectClasses = () => {
        const revealEl = document.querySelector('.reveal')
        if (!revealEl) return
        revealEl.classList.toggle('effect-shimmer', quantumEffects.shimmer)
        revealEl.classList.toggle('effect-speckle', quantumEffects.speckle)
        revealEl.classList.toggle('effect-wobble', quantumEffects.wobble)
        revealEl.classList.toggle('effect-precession', quantumEffects.precession)
        revealEl.classList.toggle('effect-wobble-filter', quantumEffects.wobbleFilter)
      }

      const toggleQuantumEffect = (effectKey) => {
        if (!(effectKey in quantumEffects)) return
        quantumEffects[effectKey] = !quantumEffects[effectKey]
        updateQuantumEffectClasses()
        updateShortcutLegend()
      }

      const updateShortcutLegend = () => {
        const fragmentItem = document.querySelector('.shortcut-item[data-shortcut="fragments"]')
        if (fragmentItem) {
          const enabled = Reveal.getConfig().fragments !== false
          fragmentItem.classList.toggle('is-on', enabled)
        }

        const effectItems = {
          shimmer: document.querySelector('.shortcut-item[data-shortcut="shimmer"]'),
          speckle: document.querySelector('.shortcut-item[data-shortcut="speckle"]'),
          wobble: document.querySelector('.shortcut-item[data-shortcut="wobble"]'),
          precession: document.querySelector('.shortcut-item[data-shortcut="precession"]'),
          wobbleFilter: document.querySelector('.shortcut-item[data-shortcut="wobble-filter"]'),
        }

        Object.entries(effectItems).forEach(([key, item]) => {
          if (!item) return
          item.classList.toggle('is-on', Boolean(quantumEffects[key]))
        })

        const ambientItem = document.querySelector('.shortcut-item[data-shortcut="ambient"]')
        if (ambientItem) {
          ambientItem.classList.toggle('is-on', ambientMode)
        }

        const debugItem = document.querySelector('.shortcut-item[data-shortcut="debug"]')
        if (debugItem) {
          debugItem.classList.toggle('is-on', vortexDebugMode)
        }

        const hudItem = document.querySelector('.shortcut-item[data-shortcut="hud"]')
        if (hudItem) {
          hudItem.classList.toggle('is-on', debugHudEnabled)
        }
      }

      const updateShortcutLegendVisibility = (section) => {
        const legend = document.querySelector('.shortcut-legend')
        if (!legend) return
        const hasFragments = Boolean(section && section.querySelector('.fragment'))
        const isChapter = Boolean(section && section.classList.contains('chapter'))
        const isTitle = section === document.querySelector('.reveal .slides > section:first-child')

        const fragmentItem = legend.querySelector('.shortcut-item[data-shortcut="fragments"]')
        if (fragmentItem) {
          fragmentItem.classList.toggle('is-hidden', !hasFragments)
        }

        const chapterItems = legend.querySelectorAll('.shortcut-item[data-scope="chapter"]')
        chapterItems.forEach((item) => {
          item.classList.toggle('is-hidden', !isChapter)
        })

        const normalItems = legend.querySelectorAll('.shortcut-item[data-scope="normal"]')
        normalItems.forEach((item) => {
          item.classList.toggle('is-hidden', isChapter || isTitle)
        })

        const showChapterLegend = isChapter && quantumLegendVisible
        const showNormalLegend = !isChapter && !isTitle

        legend.classList.toggle('is-hidden', !hasFragments && !showChapterLegend && !showNormalLegend)
        legend.classList.toggle('is-hidden-by-user', isChapter && !quantumLegendVisible)
      }

      const updateShortcutLegendPosition = () => {
        setTimeout(() => {
          const legend = document.querySelector('.shortcut-legend')
          const slideNumber = document.querySelector('.reveal .slide-number')
          if (!legend || !slideNumber) return
          const rect = slideNumber.getBoundingClientRect()
          const gap = 8
          const right = Math.max(window.innerWidth - rect.left + gap, 40)
          const bottom = Math.max(window.innerHeight - rect.bottom, 10)
          legend.style.setProperty('--legend-right', `${right}px`)
          legend.style.setProperty('--legend-bottom', `${bottom}px`)
        }, 0)
      }

      const toggleFragments = () => {
        const revealEl = document.querySelector('.reveal')
        const enabled = Reveal.getConfig().fragments !== false
        Reveal.configure({ fragments: !enabled })
        if (revealEl) {
          revealEl.classList.toggle('fragments-off', enabled)
        }
        updateShortcutLegend()

        // Sync undim state for current slide in case Reveal didn't fire events
        const currentSlide = Reveal.getCurrentSlide()
        if (currentSlide) {
          const trigger = currentSlide.querySelector('.undim-trigger.visible')
          setUndimState(currentSlide, Boolean(trigger))
        }
      }

      let quantumLegendVisible = false
      const toggleQuantumLegend = () => {
        const current = Reveal.getCurrentSlide()
        if (!current || !current.classList.contains('chapter')) return
        quantumLegendVisible = !quantumLegendVisible
        updateShortcutLegendVisibility(current)
      }

      const updateSlideNumberVisibility = (slide) => {
        const revealEl = document.querySelector('.reveal')
        if (!revealEl) return

        // Reveal's current slide can be temporarily null during startup.
        const resolvedSlide =
          slide || Reveal.getCurrentSlide() || document.querySelector('.reveal .slides section.present')
        if (!resolvedSlide) return

        const indices = Reveal.getIndices(resolvedSlide)
        const h = Number.isFinite(indices.h) ? indices.h : 0
        const v = Number.isFinite(indices.v) ? indices.v : 0
        const isFirstSlide = h === 0 && v === 0
        const isChapter = resolvedSlide.classList.contains('chapter')

        // Requested behavior:
        // - hide on all chapter/cover slides
        // - hide on the very first slide (h=0,v=0) even if it isn't a chapter cover
        const shouldHide = isFirstSlide || isChapter
        revealEl.classList.toggle('slide-number-hidden', shouldHide)
      }

      Reveal.on('ready', () => {
        addUndimTriggers()
        const revealEl = document.querySelector('.reveal')
        if (revealEl) {
          revealEl.classList.toggle('fragments-off', Reveal.getConfig().fragments === false)
        }
        updateQuantumEffectClasses()
        updateShortcutLegend()
        const currentSlide = Reveal.getCurrentSlide()
        updateShortcutLegendVisibility(currentSlide)
        updateSlideNumberVisibility(currentSlide)
        updateShortcutLegendPosition()

        // Ensure the slide counter is hidden on the initial slide after Reveal has finished laying out UI.
        setTimeout(() => updateSlideNumberVisibility(), 0)
      })

      Reveal.on('fragmentshown', (event) => {
        const frags = event.fragments || [event.fragment]
        const undimFrag = Array.from(frags).find((f) => f && f.hasAttribute('data-undim'))
        if (undimFrag) {
          setUndimState(undimFrag.closest('section'), true)
        }
      })

      Reveal.on('fragmenthidden', (event) => {
        const frags = event.fragments || [event.fragment]
        const undimFrag = Array.from(frags).find((f) => f && f.hasAttribute('data-undim'))
        if (undimFrag) {
          setUndimState(undimFrag.closest('section'), false)
        }
      })

      Reveal.on('slidechanged', (event) => {
        const trigger = event.currentSlide ? event.currentSlide.querySelector('.undim-trigger.visible') : null
        setUndimState(event.currentSlide, Boolean(trigger))
        updateShortcutLegendVisibility(event.currentSlide)
        updateSlideNumberVisibility(event.currentSlide)
        updateShortcutLegendPosition()
      })

      window.addEventListener('resize', () => {
        updateShortcutLegendPosition()
      })

      document.addEventListener('DOMContentLoaded', () => {
        const amplitudeEl = document.getElementById('wave-amplitude')
        let animationFrameId
        let startTime = null
        let lastSvgFrameTime = 0
        const amplitudePhasePrimary = Math.random() * Math.PI * 2
        const amplitudePhaseSecondary = Math.random() * Math.PI * 2
        const phaseDriftPhasePrimary = Math.random() * Math.PI * 2
        const phaseDriftPhaseSecondary = Math.random() * Math.PI * 2
        const microWavePhase = Math.random() * Math.PI * 2

        // The mathematical temporal oscillation of the standing wave
        function animateStandingWave(timestamp) {
          if (!startTime) startTime = timestamp
          const elapsed = timestamp - startTime

          // The math: Amplitude * sin(angular_frequency * time)
          // Divide elapsed by a large number (e.g., 3000) for a slow, 3-second meditative breathing.
          // Multiply by max displacement scale (e.g., 12 pixels).
          const WAVE_SCALE_PX = 7
          const WAVE_PERIOD_MS = 3000

          // Continuous noise modulation (smooth, never snaps).
          const AMPLITUDE_MOD_RANGE = 0.22 // Primary amplitude wobble (set to 0 to disable modulation).
          const AMPLITUDE_MOD_PERIOD_MS = 6200
          const AMPLITUDE_MOD_SECONDARY_RANGE = 0.13 // Secondary wobble (set to 0 to disable modulation).
          const AMPLITUDE_MOD_SECONDARY_PERIOD_MS = 11200
          const amplitudeMod =
            1 +
            AMPLITUDE_MOD_RANGE * Math.sin(amplitudePhasePrimary + (elapsed / AMPLITUDE_MOD_PERIOD_MS) * Math.PI * 2) +
            AMPLITUDE_MOD_SECONDARY_RANGE *
              Math.sin(amplitudePhaseSecondary + (elapsed / AMPLITUDE_MOD_SECONDARY_PERIOD_MS) * Math.PI * 2)

          // Continuous phase drift (keeps timing intact but adds organic wander).
          const PHASE_DRIFT_RANGE = 0.3 // Radians (set to 0 to disable phase drift).
          const PHASE_DRIFT_PERIOD_MS = 7400
          const PHASE_DRIFT_SECONDARY_RANGE = 0.15 // Radians (set to 0 to disable phase drift).
          const PHASE_DRIFT_SECONDARY_PERIOD_MS = 13200
          const phaseDrift =
            PHASE_DRIFT_RANGE * Math.sin(phaseDriftPhasePrimary + (elapsed / PHASE_DRIFT_PERIOD_MS) * Math.PI * 2) +
            PHASE_DRIFT_SECONDARY_RANGE *
              Math.sin(phaseDriftPhaseSecondary + (elapsed / PHASE_DRIFT_SECONDARY_PERIOD_MS) * Math.PI * 2)

          // Micro-wave texture layer (fixed period, random start phase for variation per load).
          const MICRO_WAVE_AMPLITUDE_PX = 1.6 // Set to 0 to disable the micro-wave layer.
          const MICRO_WAVE_PERIOD_MS = 2000
          const microWave =
            MICRO_WAVE_AMPLITUDE_PX * Math.sin(microWavePhase + (elapsed / MICRO_WAVE_PERIOD_MS) * Math.PI * 2)

          const mainWave = Math.sin(elapsed / WAVE_PERIOD_MS + phaseDrift)
          const currentScale = WAVE_SCALE_PX * amplitudeMod * mainWave + microWave

          // Throttle expensive SVG attribute writes to ~30fps
          if (timestamp - lastSvgFrameTime > 33) {
            amplitudeEl.setAttribute('scale', currentScale)
            lastSvgFrameTime = timestamp
          }

          animationFrameId = requestAnimationFrame(animateStandingWave)
        }

        const isTitleSlide = (slide) => slide === document.querySelector('.reveal .slides > section:first-child')

        const isVisualSvgSlide = (slide) => Boolean(slide && slide.querySelector('svg.r-stretch'))

        const isAmbientEligibleSlide = (slide) => {
          if (!slide) return false
          if (isTitleSlide(slide)) return false
          if (slide.classList.contains('chapter')) return false
          return true
        }

        const updateCoherentLattice = (slide) => {
          // Clean up: make sure the filter class is removed from previous slides,
          // including h1/h2/h3 nodes that had it applied during ambient mode
          document.querySelectorAll('.coherent-lattice-active').forEach((el) => {
            el.classList.remove('coherent-lattice-active')
          })

          let shouldAnimate = false
          if (slide) {
            const targets = slide.querySelectorAll('.coherent-lattice-target')
            const isChapter = slide.classList.contains('chapter')
            const isAmbient = document.querySelector('.reveal').classList.contains('effect-ambient')
            const canUseAmbient = isAmbient && isAmbientEligibleSlide(slide)
            const background = document.querySelector('.reveal .slide-background.present')

            if (targets.length > 0) {
              targets.forEach((el) => {
                el.classList.add('coherent-lattice-active')
              })
              shouldAnimate = true
            }

            if (isChapter) {
              if (background) {
                background.classList.add('coherent-lattice-active')
              }
              slide.classList.add('coherent-lattice-active')
              shouldAnimate = true
            } else if (canUseAmbient) {
              if (background) {
                background.classList.add('coherent-lattice-active')
              }
              // Apply wobble to headings on normal text slides so body text remains readable
              slide.querySelectorAll('h1, h2, h3').forEach((h) => {
                h.classList.add('coherent-lattice-active')
              })
              shouldAnimate = true
            }
          }

          if (shouldAnimate) {
            // Start the meditative breathing animation
            startTime = null
            lastSvgFrameTime = 0
            if (animationFrameId) cancelAnimationFrame(animationFrameId)
            animationFrameId = requestAnimationFrame(animateStandingWave)
          } else if (animationFrameId) {
            // If we move away, pause animation to save CPU
            cancelAnimationFrame(animationFrameId)
            animationFrameId = null
          }
        }

        let rippleInterval
        let rippleStartFrameId
        let rippleRestartTimeoutId
        const rippleSpawnTimeouts = new Set()
        let rippleGeneration = 0
        let debugHudEl
        let debugHudInterval

        const clearQuantumRippleScheduling = () => {
          rippleGeneration += 1
          if (rippleInterval) {
            clearInterval(rippleInterval)
            rippleInterval = null
          }
          if (rippleStartFrameId) {
            cancelAnimationFrame(rippleStartFrameId)
            rippleStartFrameId = null
          }
          if (rippleRestartTimeoutId) {
            clearTimeout(rippleRestartTimeoutId)
            rippleRestartTimeoutId = null
          }
          rippleSpawnTimeouts.forEach((id) => {
            clearTimeout(id)
          })
          rippleSpawnTimeouts.clear()
          updateDebugHud()
        }

        const getSlideKind = (slide) => {
          if (!slide) return 'none'
          if (isTitleSlide(slide)) return 'title'
          if (slide.classList.contains('chapter')) return 'chapter'
          if (isVisualSvgSlide(slide)) return 'visual-svg'
          return 'text'
        }

        const ensureDebugHud = () => {
          if (debugHudEl && document.body.contains(debugHudEl)) return debugHudEl
          const hud = document.createElement('div')
          hud.className = 'vortex-debug-hud is-hidden'
          hud.setAttribute('aria-live', 'polite')
          hud.setAttribute('aria-hidden', 'true')
          document.body.appendChild(hud)
          debugHudEl = hud
          return debugHudEl
        }

        const updateDebugHud = () => {
          const hud = ensureDebugHud()
          if (!debugHudEnabled) {
            hud.classList.add('is-hidden')
            hud.setAttribute('aria-hidden', 'true')
            return
          }

          const currentSlide = Reveal.getCurrentSlide()
          const revealEl = document.querySelector('.reveal')
          const isAmbient = Boolean(revealEl && revealEl.classList.contains('effect-ambient'))
          const isChapter = Boolean(currentSlide && currentSlide.classList.contains('chapter'))
          const isAmbientEligible = isAmbientEligibleSlide(currentSlide)
          const forceDebugOnTextSlide = Boolean(vortexDebugMode && currentSlide && !isChapter && isAmbientEligible)
          const canSpawnRipples = Boolean(isChapter || (isAmbient && isAmbientEligible) || forceDebugOnTextSlide)
          const usingLegacyRipplePath = Boolean(revealEl && revealEl.classList.contains('legacy-ripple-transform'))
          const cssRegisterPropertyAvailable = Boolean(
            typeof CSS !== 'undefined' && typeof CSS.registerProperty === 'function'
          )
          const kind = getSlideKind(currentSlide)
          const h = currentSlide ? currentSlide.querySelectorAll('h1, h2, h3').length : 0
          const activeRipples = document.querySelectorAll('.quantum-ripple').length
          const activeContainers = document.querySelectorAll('.quantum-ripple-container').length
          const activeWaveElements = Array.from(document.querySelectorAll('.coherent-lattice-active')).map((el) => {
            if (el.classList.contains('slide-background')) return 'bg'
            const tag = (el.tagName || '').toLowerCase()
            if (tag) return tag
            return 'node'
          })

          hud.textContent = [
            `hud: on`,
            `deterministic: ${vortexDebugMode ? 'on' : 'off'}`,
            `slide: ${kind}`,
            `ambient: ${isAmbient ? 'on' : 'off'}`,
            `ambient-eligible: ${isAmbientEligible ? 'yes' : 'no'}`,
            `ripples-allowed: ${canSpawnRipples ? 'yes' : 'no'}`,
            `ripple-path: ${usingLegacyRipplePath ? 'legacy' : 'modern'}`,
            `css.registerProperty: ${cssRegisterPropertyAvailable ? 'yes' : 'no'}`,
            `wave-loop: ${animationFrameId ? 'running' : 'stopped'}`,
            `wave-elements: ${activeWaveElements.length ? activeWaveElements.join(', ') : '-'}`,
            `ripple-interval: ${rippleInterval ? 'running' : 'stopped'}`,
            `pending-timeouts: ${rippleSpawnTimeouts.size}`,
            `ripples: ${activeRipples} / containers: ${activeContainers}`,
            `headings-in-slide: ${h}`,
          ].join('\n')

          hud.classList.remove('is-hidden')
          hud.setAttribute('aria-hidden', 'false')
        }

        const syncDebugHudLifecycle = () => {
          if (debugHudEnabled) {
            ensureDebugHud()
            updateDebugHud()
            if (!debugHudInterval) {
              debugHudInterval = setInterval(updateDebugHud, 250)
            }
          } else {
            if (debugHudInterval) {
              clearInterval(debugHudInterval)
              debugHudInterval = null
            }
            document.querySelectorAll('.quantum-ripple-container.debug-visible').forEach((container) => {
              container.classList.remove('debug-visible')
            })
            updateDebugHud()
          }
        }

        // Function to generate a single random ripple
        function spawnQuantumRipple(container) {
          const ripple = document.createElement('div')
          ripple.classList.add('quantum-ripple')
          const isDebug = vortexDebugMode

          if (isDebug) {
            // Keep exactly one ripple visible for deterministic effect debugging.
            container.querySelectorAll('.quantum-ripple').forEach((existing) => {
              existing.remove()
            })
          }

          // Depth randomization toggles (OFF by default).
          // Flip any of these to `true` to experiment with the depth model.
          // When all are `false`, the vortex uses the CSS fallback values (no extra randomness).
          const ENABLE_DEPTH_SIZE = false // Randomly scales radius (near/far)
          const ENABLE_DEPTH_BLUR = false // Near = sharper, far = blurrier
          const ENABLE_DEPTH_CONTRAST = false // Near = higher contrast
          const ENABLE_DEPTH_OPACITY = false // Near = more visible at the peak
          const ENABLE_DEPTH_COLORS = false // Near = deeper/darker core + stronger highlights

          // Ripple base size (pixels)
          const RIPPLE_SIZE_MIN_PX = 10 // minimum diameter
          const RIPPLE_SIZE_JITTER_PX = 20 // random additional range (0..this)
          // Randomize the base size for a softer, larger vortex (min..min+jitter).
          // In debug mode keep the size fixed for deterministic effect checks.
          const baseSize = isDebug
            ? VORTEX_DEBUG_MIN_RADIUS_PX * 2
            : RIPPLE_SIZE_MIN_PX + Math.random() * RIPPLE_SIZE_JITTER_PX
          ripple.style.width = `${baseSize}px`
          ripple.style.height = `${baseSize}px`

          // Randomize position across the slide (or fix in debug mode).
          // The ripple transform uses translate(-50%, -50%), so anchor by center point.
          if (isDebug) {
            const debugCenterPx = VORTEX_DEBUG_MARGIN_PX + baseSize / 2
            ripple.style.left = `${debugCenterPx}px`
            ripple.style.top = `${debugCenterPx}px`
          } else {
            const x = Math.random() * 100
            const y = Math.random() * 100
            ripple.style.left = `${x}%`
            ripple.style.top = `${y}%`
          }

          const enableDepth =
            ENABLE_DEPTH_SIZE ||
            ENABLE_DEPTH_BLUR ||
            ENABLE_DEPTH_CONTRAST ||
            ENABLE_DEPTH_OPACITY ||
            ENABLE_DEPTH_COLORS

          if (enableDepth) {
            // Shared depth factor so all enabled properties feel coordinated.
            // Depth range: 0.7 (far) .. 1.4 (near)
            const depth = 0.7 + Math.random() * 0.7
            const depthNormalized = (depth - 0.7) / 0.7 // 0..1

            if (ENABLE_DEPTH_SIZE) {
              const size = baseSize * depth
              ripple.style.width = `${size}px`
              ripple.style.height = `${size}px`
            }

            if (ENABLE_DEPTH_BLUR) {
              const blur = 1.8 - depthNormalized * 0.7
              ripple.style.setProperty('--vortex-blur', `${blur.toFixed(2)}px`)
            }

            if (ENABLE_DEPTH_CONTRAST) {
              const contrast = 1.0 + depthNormalized * 0.22
              ripple.style.setProperty('--vortex-contrast', contrast.toFixed(2))
            }

            if (ENABLE_DEPTH_OPACITY) {
              const opacityMid = 0.35 + depthNormalized * 0.35
              ripple.style.setProperty('--vortex-opacity-mid', opacityMid.toFixed(2))
            }

            if (ENABLE_DEPTH_COLORS) {
              const core = 0.28 + depthNormalized * 0.18
              const inner = 0.18 + depthNormalized * 0.08
              const shadow = 0.18 + depthNormalized * 0.12
              const highlight = 0.22 + depthNormalized * 0.08
              const highlightStrong = 0.28 + depthNormalized * 0.1

              ripple.style.setProperty('--vortex-core', core.toFixed(2))
              ripple.style.setProperty('--vortex-inner', inner.toFixed(2))
              ripple.style.setProperty('--vortex-shadow', shadow.toFixed(2))
              ripple.style.setProperty('--vortex-highlight', highlight.toFixed(2))
              ripple.style.setProperty('--vortex-highlight-strong', highlightStrong.toFixed(2))
            }
          }

          // Ripple expansion timing (seconds)
          const EXPAND_DURATION_BASE_SECONDS = 0.7 // minimum base duration before scaling
          const EXPAND_DURATION_JITTER_SECONDS = 3 // random additional range (0..this)
          const EXPAND_DURATION_MULTIPLIER = 1.0 // global slow-down multiplier

          const expandDurationSeconds = isDebug
            ? VORTEX_DEBUG_DURATION_SECONDS
            : (EXPAND_DURATION_BASE_SECONDS + Math.random() * EXPAND_DURATION_JITTER_SECONDS) *
              EXPAND_DURATION_MULTIPLIER
          ripple.style.setProperty('--expand-duration', `${expandDurationSeconds}s`)
          if (isDebug) {
            ripple.style.setProperty('--expand-easing', 'linear')
          } else {
            ripple.style.removeProperty('--expand-easing')
          }

          // Add it to the screen
          container.appendChild(ripple)

          // Garbage collection: remove the DOM element after animation finishes
          setTimeout(() => {
            if (container.contains(ripple)) {
              ripple.remove()
            }
          }, expandDurationSeconds * 1000)
        }

        const getRippleContainer = (slide) => {
          if (!slide) return null

          // Prefer the full-slide background layer when available
          const background = document.querySelector('.reveal .slide-background.present')
          let containerParent = slide
          if (background) {
            const backgroundContent = background.querySelector('.slide-background-content')
            containerParent = backgroundContent || background
          }

          let container = containerParent.querySelector('.quantum-ripple-container')
          if (!container) {
            container = document.createElement('div')
            container.classList.add('quantum-ripple-container')
            // Dim ripples heavily on normal text slides so they do not overpower content
            if (!slide.classList.contains('chapter')) {
              container.classList.add('ambient-mode')
              const bg = document.createElement('div')
              bg.classList.add('ambient-gradient-bg')
              container.appendChild(bg)
            }
            containerParent.appendChild(container)
          }

          return container
        }

        const updateQuantumRipples = (slide) => {
          // Clear old schedules if we leave slide/state
          clearQuantumRippleScheduling()

          if (!slide) {
            return
          }

          const isTitle = isTitleSlide(slide)
          const isChapter = slide.classList.contains('chapter')
          const isAmbient = document.querySelector('.reveal').classList.contains('effect-ambient')
          const canUseAmbient = isAmbient && isAmbientEligibleSlide(slide)
          const forceDebugOnTextSlide = vortexDebugMode && isAmbientEligibleSlide(slide)
          const generation = rippleGeneration

          // Stop completely if this slide should not have ripples
          if (isTitle) {
            updateDebugHud()
            return
          }
          if (!isChapter && !canUseAmbient && !forceDebugOnTextSlide) {
            updateDebugHud()
            return
          }

          const startRipples = () => {
            if (generation !== rippleGeneration) return
            if (Reveal.getCurrentSlide() !== slide) return
            const container = getRippleContainer(slide)
            if (!container) return
            if (!isChapter) {
              container.classList.toggle('debug-visible', forceDebugOnTextSlide)
            }

            // Drop spawn rate controls
            const INITIAL_DROP_COUNT = 15 // how many drops appear shortly after entering a cover slide
            const INITIAL_DROP_SPREAD_MS = 3000 // spread those initial drops over 0..this window
            const DROP_INTERVAL_MS = 200 // steady-state rate: one drop per interval
            const DEBUG_DROP_INTERVAL_MS = VORTEX_DEBUG_DURATION_SECONDS * 1000 + VORTEX_DEBUG_RESPAWN_GAP_MS

            const initialDropCount = vortexDebugMode ? 1 : INITIAL_DROP_COUNT
            const initialDropSpreadMs = vortexDebugMode ? 0 : INITIAL_DROP_SPREAD_MS
            const dropIntervalMs = vortexDebugMode ? DEBUG_DROP_INTERVAL_MS : DROP_INTERVAL_MS

            // 1. Spawn a couple of ripples immediately so the screen isn't empty
            for (let i = 0; i < initialDropCount; i++) {
              const delayMs = initialDropSpreadMs > 0 ? Math.random() * initialDropSpreadMs : 0
              const timeoutId = setTimeout(() => {
                rippleSpawnTimeouts.delete(timeoutId)
                if (generation !== rippleGeneration) return
                if (Reveal.getCurrentSlide() !== slide) return
                spawnQuantumRipple(container)
              }, delayMs)
              rippleSpawnTimeouts.add(timeoutId)
            }

            // 2. Continuously spawn new ripples (e.g., one every 1.2 seconds)
            const intervalId = setInterval(() => {
              if (generation !== rippleGeneration) {
                clearInterval(intervalId)
                return
              }
              if (Reveal.getCurrentSlide() !== slide) return
              const liveContainer = getRippleContainer(slide)
              if (liveContainer) {
                if (!isChapter) {
                  liveContainer.classList.toggle('debug-visible', forceDebugOnTextSlide)
                }
                spawnQuantumRipple(liveContainer)
              }
            }, dropIntervalMs)
            rippleInterval = intervalId
            updateDebugHud()
          }

          // Delay to allow Reveal to finish background swaps during transitions
          rippleStartFrameId = requestAnimationFrame(() => {
            if (generation !== rippleGeneration) return
            startRipples()
            rippleRestartTimeoutId = setTimeout(() => {
              if (generation !== rippleGeneration) return
              if (!rippleInterval) {
                startRipples()
              }
            }, 120)
            updateDebugHud()
          })
        }

        // Reveal.js event listener to start/stop the effect
        Reveal.on('slidechanged', (event) => {
          updateCoherentLattice(event.currentSlide)
          updateQuantumRipples(event.currentSlide)
          updateDebugHud()
        })

        // Listen for the custom ambient toggle event
        document.addEventListener('toggleAmbient', () => {
          const slide = Reveal.getCurrentSlide()
          const isAmbient = document.querySelector('.reveal').classList.contains('effect-ambient')

          if (!isAmbient) {
            // Aggressive cleanup: remove wobble classes from normal slides immediately
            document.querySelectorAll('.coherent-lattice-active').forEach((el) => {
              // Keep it on chapter backgrounds, remove from normal slide headers
              if (el.tagName.match(/^H[1-3]$/i)) {
                el.classList.remove('coherent-lattice-active')
              }
            })
            // Also clear any injected quantum ripple containers from normal slides
            document.querySelectorAll('section:not(.chapter) .quantum-ripple-container').forEach((c) => {
              c.remove()
            })
            // Also remove the class from the slide-background if it's a normal slide
            const bg = document.querySelector('.reveal .slide-background.present')
            if (bg && slide && !slide.classList.contains('chapter')) {
              bg.classList.remove('coherent-lattice-active')
            }
          }

          updateCoherentLattice(slide)
          updateQuantumRipples(slide)
          updateDebugHud()
        })

        document.addEventListener('toggleVortexDebug', () => {
          updateQuantumRipples(Reveal.getCurrentSlide())
          updateDebugHud()
        })

        document.addEventListener('toggleDebugHud', () => {
          syncDebugHudLifecycle()
          updateDebugHud()
        })

        // Apply on initial load as well
        syncDebugHudLifecycle()
        updateCoherentLattice(Reveal.getCurrentSlide())
        updateQuantumRipples(Reveal.getCurrentSlide())
        updateDebugHud()
      })
    </script>
  </body>
</html>
